"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ModuleRegistry").Ice;

Ice._ModuleRegistry.require(module, ["../Ice/Stream", "../Ice/Debug", "../Ice/Protocol"]);

var OutputStream = Ice.OutputStream;
var Debug = Ice.Debug;
var Protocol = Ice.Protocol;
var udpOverhead = 20 + 8;

var BatchRequestQueue =
/*#__PURE__*/
function () {
  function BatchRequestQueue(instance, datagram) {
    _classCallCheck(this, BatchRequestQueue);

    this._batchStreamInUse = false;
    this._batchRequestNum = 0;
    this._batchStream = new OutputStream(instance, Protocol.currentProtocolEncoding);

    this._batchStream.writeBlob(Protocol.requestBatchHdr);

    this._batchMarker = this._batchStream.size;
    this._exception = null;
    this._maxSize = instance.batchAutoFlushSize();

    if (this._maxSize > 0 && datagram) {
      var udpSndSize = instance.initializationData().properties.getPropertyAsIntWithDefault("Ice.UDP.SndSize", 65535 - udpOverhead);

      if (udpSndSize < this._maxSize) {
        this._maxSize = udpSndSize;
      }
    }
  }

  _createClass(BatchRequestQueue, [{
    key: "prepareBatchRequest",
    value: function prepareBatchRequest(os) {
      if (this._exception) {
        throw this._exception;
      }

      this._batchStream.swap(os);
    }
  }, {
    key: "finishBatchRequest",
    value: function finishBatchRequest(os, proxy, operation) {
      //
      // No need for synchronization, no other threads are supposed
      // to modify the queue since we set this._batchStreamInUse to true.
      //
      this._batchStream.swap(os);

      try {
        if (this._maxSize > 0 && this._batchStream.size >= this._maxSize) {
          proxy.ice_flushBatchRequests(); // Auto flush
        }

        Debug.assert(this._batchMarker < this._batchStream.size);
        this._batchMarker = this._batchStream.size;
        ++this._batchRequestNum;
      } finally {
        this._batchStream.resize(this._batchMarker);
      }
    }
  }, {
    key: "abortBatchRequest",
    value: function abortBatchRequest(os) {
      this._batchStream.swap(os);

      this._batchStream.resize(this._batchMarker);
    }
  }, {
    key: "swap",
    value: function swap(os) {
      if (this._batchRequestNum === 0) {
        return 0;
      }

      var lastRequest = null;

      if (this._batchMarker < this._batchStream.size) {
        var length = this._batchStream.size - this._batchMarker;
        this._batchStream.pos = this._batchMarker;
        lastRequest = this._batchStream.buffer.getArray(length);

        this._batchStream.resize(this._batchMarker);
      }

      var requestNum = this._batchRequestNum;

      this._batchStream.swap(os); //
      // Reset the batch.
      //


      this._batchRequestNum = 0;

      this._batchStream.writeBlob(Protocol.requestBatchHdr);

      this._batchMarker = this._batchStream.size;

      if (lastRequest !== null) {
        this._batchStream.writeBlob(lastRequest);
      }

      return requestNum;
    }
  }, {
    key: "destroy",
    value: function destroy(ex) {
      this._exception = ex;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._batchStream.size === Protocol.requestBatchHdr.length;
    }
  }]);

  return BatchRequestQueue;
}();

Ice.BatchRequestQueue = BatchRequestQueue;
module.exports.Ice = Ice;