"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ModuleRegistry").Ice;

Ice._ModuleRegistry.require(module, ["../Ice/AsyncResultBase", "../Ice/Debug", "../Ice/Identity", "../Ice/LocalException", "../Ice/PropertyNames", "../Ice/Router", "../Ice/ServantManager", "../Ice/StringUtil", "../Ice/UUID", "../Ice/ArrayUtil", "../Ice/Promise", "../Ice/Timer"]);

var AsyncResultBase = Ice.AsyncResultBase;
var Debug = Ice.Debug;
var Identity = Ice.Identity;
var PropertyNames = Ice.PropertyNames;
var ServantManager = Ice.ServantManager;
var StringUtil = Ice.StringUtil;
var ArrayUtil = Ice.ArrayUtil;
var Timer = Ice.Timer;
var _suffixes = ["ACM", "AdapterId", "Endpoints", "Locator", "Locator.EncodingVersion", "Locator.EndpointSelection", "Locator.ConnectionCached", "Locator.PreferSecure", "Locator.CollocationOptimized", "Locator.Router", "MessageSizeMax", "PublishedEndpoints", "ReplicaGroupId", "Router", "Router.EncodingVersion", "Router.EndpointSelection", "Router.ConnectionCached", "Router.PreferSecure", "Router.CollocationOptimized", "Router.Locator", "Router.Locator.EndpointSelection", "Router.Locator.ConnectionCached", "Router.Locator.PreferSecure", "Router.Locator.CollocationOptimized", "Router.Locator.LocatorCacheTimeout", "Router.Locator.InvocationTimeout", "Router.LocatorCacheTimeout", "Router.InvocationTimeout", "ProxyOptions", "ThreadPool.Size", "ThreadPool.SizeMax", "ThreadPool.SizeWarn", "ThreadPool.StackSize", "ThreadPool.Serialize"];
var StateUninitialized = 0; // Just constructed.

var StateHeld = 1; // const StateWaitActivate = 2;

var StateActive = 3; // const StateDeactivating = 4;

var StateDeactivated = 5;
var StateDestroyed = 6; //
// Only for use by IceInternal.ObjectAdapterFactory
//

var ObjectAdapterI =
/*#__PURE__*/
function () {
  function ObjectAdapterI(instance, communicator, objectAdapterFactory, name, router, noConfig, promise) {
    var _this = this;

    _classCallCheck(this, ObjectAdapterI);

    this._instance = instance;
    this._communicator = communicator;
    this._objectAdapterFactory = objectAdapterFactory;
    this._servantManager = new ServantManager(instance, name);
    this._name = name;
    this._publishedEndpoints = [];
    this._routerInfo = null;
    this._state = StateUninitialized;
    this._noConfig = noConfig;
    this._statePromises = [];

    if (this._noConfig) {
      this._reference = this._instance.referenceFactory().createFromString("dummy -t", "");
      this._messageSizeMax = this._instance.messageSizeMax();
      promise.resolve(this);
      return;
    }

    var properties = this._instance.initializationData().properties;

    var unknownProps = [];
    var noProps = this.filterProperties(unknownProps); //
    // Warn about unknown object adapter properties.
    //

    if (unknownProps.length !== 0 && properties.getPropertyAsIntWithDefault("Ice.Warn.UnknownProperties", 1) > 0) {
      var message = ["found unknown properties for object adapter `" + name + "':"];
      unknownProps.forEach(function (unknownProp) {
        return message.push("\n    " + unknownProp);
      });

      this._instance.initializationData().logger.warning(message.join(""));
    } //
    // Make sure named adapter has some configuration.
    //


    if (router === null && noProps) {
      throw new Ice.InitializationException("object adapter `".concat(this._name, "' requires configuration"));
    } //
    // Setup a reference to be used to get the default proxy options
    // when creating new proxies. By default, create twoway proxies.
    //


    var proxyOptions = properties.getPropertyWithDefault(this._name + ".ProxyOptions", "-t");

    try {
      this._reference = this._instance.referenceFactory().createFromString("dummy " + proxyOptions, "");
    } catch (e) {
      if (e instanceof Ice.ProxyParseException) {
        throw new Ice.InitializationException("invalid proxy options `".concat(proxyOptions, "' for object adapter `").concat(name, "'"));
      } else {
        throw e;
      }
    }

    {
      var defaultMessageSizeMax = this._instance.messageSizeMax() / 1024;
      var num = properties.getPropertyAsIntWithDefault(this._name + ".MessageSizeMax", defaultMessageSizeMax);

      if (num < 1 || num > 0x7fffffff / 1024) {
        this._messageSizeMax = 0x7fffffff;
      } else {
        this._messageSizeMax = num * 1024; // Property is in kilobytes, _messageSizeMax in bytes
      }
    }

    try {
      if (router === null) {
        router = Ice.RouterPrx.uncheckedCast(this._instance.proxyFactory().propertyToProxy(this._name + ".Router"));
      }

      var p;

      if (router !== null) {
        this._routerInfo = this._instance.routerManager().find(router);
        Debug.assert(this._routerInfo !== null); //
        // Make sure this router is not already registered with another adapter.
        //

        if (this._routerInfo.getAdapter() !== null) {
          throw new Ice.AlreadyRegisteredException("object adapter with router", Ice.identityToString(router.ice_getIdentity(), this._instance.toStringMode()));
        } //
        // Associate this object adapter with the router. This way,
        // new outgoing connections to the router's client proxy will
        // use this object adapter for callbacks.
        //


        this._routerInfo.setAdapter(this); //
        // Also modify all existing outgoing connections to the
        // router's client proxy to use this object adapter for
        // callbacks.
        //


        p = this._instance.outgoingConnectionFactory().setRouterInfo(this._routerInfo);
      } else {
        var endpoints = properties.getProperty(this._name + ".Endpoints");

        if (endpoints.length > 0) {
          throw new Ice.FeatureNotSupportedException("object adapter endpoints not supported");
        }

        p = Ice.Promise.resolve();
      }

      p.then(function () {
        return _this.computePublishedEndpoints();
      }).then(function (endpoints) {
        _this._publishedEndpoints = endpoints;
        promise.resolve(_this);
      }, function (ex) {
        _this.destroy();

        promise.reject(ex);
      });
    } catch (ex) {
      this.destroy();
      throw ex;
    }
  }

  _createClass(ObjectAdapterI, [{
    key: "getName",
    value: function getName() {
      //
      // No mutex lock necessary, _name is immutable.
      //
      return this._noConfig ? "" : this._name;
    }
  }, {
    key: "getCommunicator",
    value: function getCommunicator() {
      return this._communicator;
    }
  }, {
    key: "activate",
    value: function activate() {
      var promise = new AsyncResultBase(this._communicator, "activate", null, null, this);
      this.setState(StateActive);
      promise.resolve();
      return promise;
    }
  }, {
    key: "hold",
    value: function hold() {
      this.checkForDeactivation();
      this.setState(StateHeld);
    }
  }, {
    key: "waitForHold",
    value: function waitForHold() {
      var promise = new AsyncResultBase(this._communicator, "waitForHold", null, null, this);

      try {
        this.checkForDeactivation();
        this.waitState(StateHeld, promise);
      } catch (ex) {
        promise.reject(ex);
      }

      return promise;
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      var promise = new AsyncResultBase(this._communicator, "deactivate", null, null, this);

      if (this._state < StateDeactivated) {
        this.setState(StateDeactivated);

        this._instance.outgoingConnectionFactory().removeAdapter(this);
      }

      promise.resolve();
      return promise;
    }
  }, {
    key: "waitForDeactivate",
    value: function waitForDeactivate() {
      var promise = new AsyncResultBase(this._communicator, "waitForDeactivate", null, null, this);
      this.waitState(StateDeactivated, promise);
      return promise;
    }
  }, {
    key: "isDeactivated",
    value: function isDeactivated() {
      return this._state >= StateDeactivated;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      // NOTE: we don't call waitForDeactivate since it's currently a no-op.
      return this.deactivate().then(function () {
        if (_this2._state < StateDestroyed) {
          _this2.setState(StateDestroyed);

          _this2._servantManager.destroy();

          _this2._objectAdapterFactory.removeObjectAdapter(_this2);

          _this2._publishedEndpoints = [];
        }

        var promise = new AsyncResultBase(_this2._communicator, "destroy", null, null, _this2);
        promise.resolve();
        return promise;
      });
    }
  }, {
    key: "add",
    value: function add(object, ident) {
      return this.addFacet(object, ident, "");
    }
  }, {
    key: "addFacet",
    value: function addFacet(object, ident, facet) {
      this.checkForDeactivation();
      this.checkIdentity(ident);
      this.checkServant(object); //
      // Create a copy of the Identity argument, in case the caller
      // reuses it.
      //

      var id = ident.clone();

      this._servantManager.addServant(object, id, facet);

      return this.newProxy(id, facet);
    }
  }, {
    key: "addWithUUID",
    value: function addWithUUID(object) {
      return this.addFacetWithUUID(object, "");
    }
  }, {
    key: "addFacetWithUUID",
    value: function addFacetWithUUID(object, facet) {
      return this.addFacet(object, new Identity(Ice.generateUUID(), ""), facet);
    }
  }, {
    key: "addDefaultServant",
    value: function addDefaultServant(servant, category) {
      this.checkServant(servant);
      this.checkForDeactivation();

      this._servantManager.addDefaultServant(servant, category);
    }
  }, {
    key: "remove",
    value: function remove(ident) {
      return this.removeFacet(ident, "");
    }
  }, {
    key: "removeFacet",
    value: function removeFacet(ident, facet) {
      this.checkForDeactivation();
      this.checkIdentity(ident);
      return this._servantManager.removeServant(ident, facet);
    }
  }, {
    key: "removeAllFacets",
    value: function removeAllFacets(ident) {
      this.checkForDeactivation();
      this.checkIdentity(ident);
      return this._servantManager.removeAllFacets(ident);
    }
  }, {
    key: "removeDefaultServant",
    value: function removeDefaultServant(category) {
      this.checkForDeactivation();
      return this._servantManager.removeDefaultServant(category);
    }
  }, {
    key: "find",
    value: function find(ident) {
      return this.findFacet(ident, "");
    }
  }, {
    key: "findFacet",
    value: function findFacet(ident, facet) {
      this.checkForDeactivation();
      this.checkIdentity(ident);
      return this._servantManager.findServant(ident, facet);
    }
  }, {
    key: "findAllFacets",
    value: function findAllFacets(ident) {
      this.checkForDeactivation();
      this.checkIdentity(ident);
      return this._servantManager.findAllFacets(ident);
    }
  }, {
    key: "findByProxy",
    value: function findByProxy(proxy) {
      this.checkForDeactivation();

      var ref = proxy._getReference();

      return this.findFacet(ref.getIdentity(), ref.getFacet());
    }
  }, {
    key: "findDefaultServant",
    value: function findDefaultServant(category) {
      this.checkForDeactivation();
      return this._servantManager.findDefaultServant(category);
    }
  }, {
    key: "addServantLocator",
    value: function addServantLocator(locator, prefix) {
      this.checkForDeactivation();

      this._servantManager.addServantLocator(locator, prefix);
    }
  }, {
    key: "removeServantLocator",
    value: function removeServantLocator(prefix) {
      this.checkForDeactivation();
      return this._servantManager.removeServantLocator(prefix);
    }
  }, {
    key: "findServantLocator",
    value: function findServantLocator(prefix) {
      this.checkForDeactivation();
      return this._servantManager.findServantLocator(prefix);
    }
  }, {
    key: "createProxy",
    value: function createProxy(ident) {
      this.checkForDeactivation();
      this.checkIdentity(ident);
      return this.newProxy(ident, "");
    }
  }, {
    key: "createDirectProxy",
    value: function createDirectProxy(ident) {
      return this.createProxy(ident);
    }
  }, {
    key: "createIndirectProxy",
    value: function createIndirectProxy(ident) {
      throw new Ice.FeatureNotSupportedException("createIndirectProxy not supported");
    }
  }, {
    key: "setLocator",
    value: function setLocator(locator) {
      throw new Ice.FeatureNotSupportedException("setLocator not supported");
    }
  }, {
    key: "getEndpoints",
    value: function getEndpoints() {
      return [];
    }
  }, {
    key: "refreshPublishedEndpoints",
    value: function refreshPublishedEndpoints() {
      var _this3 = this;

      this.checkForDeactivation();
      return this.computePublishedEndpoints().then(function (endpoints) {
        _this3._publishedEndpoints = endpoints;
      });
    }
  }, {
    key: "getPublishedEndpoints",
    value: function getPublishedEndpoints() {
      return ArrayUtil.clone(this._publishedEndpoints);
    }
  }, {
    key: "setPublishedEndpoints",
    value: function setPublishedEndpoints(newEndpoints) {
      this.checkForDeactivation();

      if (this._routerInfo !== null) {
        throw new Error("can't set published endpoints on object adapter associated with a router");
      }

      this._publishedEndpoints = ArrayUtil.clone(newEndpoints);
    }
  }, {
    key: "getServantManager",
    value: function getServantManager() {
      //
      // _servantManager is immutable.
      //
      return this._servantManager;
    }
  }, {
    key: "setAdapterOnConnection",
    value: function setAdapterOnConnection(connection) {
      this.checkForDeactivation();
      connection.setAdapterAndServantManager(this, this._servantManager);
    }
  }, {
    key: "messageSizeMax",
    value: function messageSizeMax() {
      return this._messageSizeMax;
    }
  }, {
    key: "newProxy",
    value: function newProxy(ident, facet) {
      //
      // Now we also add the endpoints of the router's server proxy, if
      // any. This way, object references created by this object adapter
      // will also point to the router's server proxy endpoints.
      //
      //
      // Create a reference and return a proxy for this reference.
      //
      return this._instance.proxyFactory().referenceToProxy(this._instance.referenceFactory().create(ident, facet, this._reference, this._publishedEndpoints));
    }
  }, {
    key: "checkForDeactivation",
    value: function checkForDeactivation() {
      if (this._state >= StateDeactivated) {
        var ex = new Ice.ObjectAdapterDeactivatedException();
        ex.name = this.getName();
        throw ex;
      }
    }
  }, {
    key: "checkIdentity",
    value: function checkIdentity(ident) {
      if (ident.name === undefined || ident.name === null || ident.name.length === 0) {
        throw new Ice.IllegalIdentityException(ident);
      }

      if (ident.category === undefined || ident.category === null) {
        ident.category = "";
      }
    }
  }, {
    key: "checkServant",
    value: function checkServant(servant) {
      if (servant === undefined || servant === null) {
        throw new Ice.IllegalServantException("cannot add null servant to Object Adapter");
      }
    }
  }, {
    key: "computePublishedEndpoints",
    value: function computePublishedEndpoints() {
      var _this4 = this;

      var p;

      if (this._routerInfo !== null) {
        p = this._routerInfo.getServerEndpoints().then(function (endpts) {
          //
          // Remove duplicate endpoints, so we have a list of unique endpoints.
          //
          var endpoints = [];
          endpts.forEach(function (endpoint) {
            if (endpoints.findIndex(function (value) {
              return endpoint.equals(value);
            }) === -1) {
              endpoints.push(endpoint);
            }
          });
          return endpoints;
        });
      } else {
        //
        // Parse published endpoints. If set, these are used in proxies
        // instead of the connection factory Endpoints.
        //
        var endpoints = [];

        var s = this._instance.initializationData().properties.getProperty(this._name + ".PublishedEndpoints");

        var delim = " \t\n\r";
        var end = 0;
        var beg;

        while (end < s.length) {
          beg = StringUtil.findFirstNotOf(s, delim, end);

          if (beg === -1) {
            if (s != "") {
              throw new Ice.EndpointParseException("invalid empty object adapter endpoint");
            }

            break;
          }

          end = beg;

          while (true) {
            end = s.indexOf(':', end);

            if (end == -1) {
              end = s.length;
              break;
            } else {
              var quoted = false;
              var quote = beg;

              while (true) {
                quote = s.indexOf("\"", quote);

                if (quote == -1 || end < quote) {
                  break;
                } else {
                  quote = s.indexOf("\"", ++quote);

                  if (quote == -1) {
                    break;
                  } else if (end < quote) {
                    quoted = true;
                    break;
                  }

                  ++quote;
                }
              }

              if (!quoted) {
                break;
              }

              ++end;
            }
          }

          var es = s.substring(beg, end);

          var endp = this._instance.endpointFactoryManager().create(es, false);

          if (endp === null) {
            throw new Ice.EndpointParseException("invalid object adapter endpoint `" + s + "'");
          }

          endpoints.push(endp);
        }

        p = Ice.Promise.resolve(endpoints);
      }

      return p.then(function (endpoints) {
        if (_this4._instance.traceLevels().network >= 1 && endpoints.length > 0) {
          var _s = [];

          _s.push("published endpoints for object adapter `");

          _s.push(_this4._name);

          _s.push("':\n");

          var first = true;
          endpoints.forEach(function (endpoint) {
            if (!first) {
              _s.push(":");
            }

            _s.push(endpoint.toString());

            first = false;
          });

          _this4._instance.initializationData().logger.trace(_this4._instance.traceLevels().networkCat, _s.toString());
        }

        return endpoints;
      });
    }
  }, {
    key: "filterProperties",
    value: function filterProperties(unknownProps) {
      //
      // Do not create unknown properties list if Ice prefix, i.e., Ice, Glacier2, etc.
      //
      var addUnknown = true;
      var prefix = this._name + ".";

      for (var i = 0; i < PropertyNames.clPropNames.length; ++i) {
        if (prefix.indexOf(PropertyNames.clPropNames[i] + ".") === 0) {
          addUnknown = false;
          break;
        }
      }

      var noProps = true;

      var props = this._instance.initializationData().properties.getPropertiesForPrefix(prefix);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = props.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;
          var valid = false;

          for (var _i = 0; _i < _suffixes.length; ++_i) {
            if (key === prefix + _suffixes[_i]) {
              noProps = false;
              valid = true;
              break;
            }
          }

          if (!valid && addUnknown) {
            unknownProps.push(key);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return noProps;
    }
  }, {
    key: "setState",
    value: function setState(state) {
      var _this5 = this;

      if (this._state === state) {
        return;
      }

      this._state = state;
      var promises = [];
      (state < StateDeactivated ? [state] : [StateHeld, StateDeactivated]).forEach(function (s) {
        if (_this5._statePromises[s]) {
          promises = promises.concat(_this5._statePromises[s]);
          delete _this5._statePromises[s];
        }
      });

      if (promises.length > 0) {
        Timer.setImmediate(function () {
          return promises.forEach(function (p) {
            return p.resolve();
          });
        });
      }
    }
  }, {
    key: "waitState",
    value: function waitState(state, promise) {
      if (this._state < StateDeactivated && (state === StateHeld && this._state !== StateHeld || state === StateDeactivated)) {
        if (this._statePromises[state]) {
          this._statePromises[state].push(promise);
        } else {
          this._statePromises[state] = [promise];
        }
      } else {
        promise.resolve();
      }
    }
  }]);

  return ObjectAdapterI;
}();

Ice.ObjectAdapterI = ObjectAdapterI;
module.exports.Ice = Ice;