"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ModuleRegistry").Ice;

Ice._ModuleRegistry.require(module, ["../Ice/Debug", "../Ice/HashMap", "../Ice/Promise", "../Ice/LocalException", "../Ice/Exception"]);

var Debug = Ice.Debug;
var HashMap = Ice.HashMap;

var RouterInfo =
/*#__PURE__*/
function () {
  function RouterInfo(router) {
    _classCallCheck(this, RouterInfo);

    this._router = router;
    Debug.assert(this._router !== null);
    this._clientEndpoints = null;
    this._adapter = null;
    this._identities = new HashMap(HashMap.compareEquals); // Set<Identity> = Map<Identity, 1>

    this._evictedIdentities = [];
    this._hasRoutingTable = false;
  }

  _createClass(RouterInfo, [{
    key: "destroy",
    value: function destroy() {
      this._clientEndpoints = [];
      this._adapter = null;

      this._identities.clear();
    }
  }, {
    key: "equals",
    value: function equals(rhs) {
      if (this === rhs) {
        return true;
      }

      if (rhs instanceof RouterInfo) {
        return this._router.equals(rhs._router);
      }

      return false;
    }
  }, {
    key: "hashCode",
    value: function hashCode() {
      return this._router.hashCode();
    }
  }, {
    key: "getRouter",
    value: function getRouter() {
      //
      // No mutex lock necessary, _router is immutable.
      //
      return this._router;
    }
  }, {
    key: "getClientEndpoints",
    value: function getClientEndpoints() {
      var _this = this;

      var promise = new Ice.Promise();

      if (this._clientEndpoints !== null) {
        promise.resolve(this._clientEndpoints);
      } else {
        this._router.getClientProxy().then(function (result) {
          return _this.setClientEndpoints(result[0], result[1] !== undefined ? result[1] : true, promise);
        }).catch(promise.reject);
      }

      return promise;
    }
  }, {
    key: "getServerEndpoints",
    value: function getServerEndpoints() {
      return this._router.getServerProxy().then(function (serverProxy) {
        if (serverProxy === null) {
          throw new Ice.NoEndpointException();
        }

        serverProxy = serverProxy.ice_router(null); // The server proxy cannot be routed.

        return serverProxy._getReference().getEndpoints();
      });
    }
  }, {
    key: "addProxy",
    value: function addProxy(proxy) {
      var _this2 = this;

      Debug.assert(proxy !== null);

      if (!this._hasRoutingTable) {
        return Ice.Promise.resolve(); // The router implementation doesn't maintain a routing table.
      } else if (this._identities.has(proxy.ice_getIdentity())) {
        //
        // Only add the proxy to the router if it's not already in our local map.
        //
        return Ice.Promise.resolve();
      } else {
        return this._router.addProxies([proxy]).then(function (evictedProxies) {
          _this2.addAndEvictProxies(proxy, evictedProxies);
        });
      }
    }
  }, {
    key: "setAdapter",
    value: function setAdapter(adapter) {
      this._adapter = adapter;
    }
  }, {
    key: "getAdapter",
    value: function getAdapter() {
      return this._adapter;
    }
  }, {
    key: "clearCache",
    value: function clearCache(ref) {
      this._identities.delete(ref.getIdentity());
    }
  }, {
    key: "setClientEndpoints",
    value: function setClientEndpoints(clientProxy, hasRoutingTable, promise) {
      var _this3 = this;

      if (this._clientEndpoints === null) {
        this._hasRoutingTable = hasRoutingTable;

        if (clientProxy === null) {
          //
          // If getClientProxy() return nil, use router endpoints.
          //
          this._clientEndpoints = this._router._getReference().getEndpoints();
          promise.resolve(this._clientEndpoints);
        } else {
          clientProxy = clientProxy.ice_router(null); // The client proxy cannot be routed.
          //
          // In order to avoid creating a new connection to the
          // router, we must use the same timeout as the already
          // existing connection.
          //

          this._router.ice_getConnection().then(function (con) {
            _this3._clientEndpoints = clientProxy.ice_timeout(con.timeout())._getReference().getEndpoints();
            promise.resolve(_this3._clientEndpoints);
          }).catch(promise.reject);
        }
      } else {
        promise.resolve(this._clientEndpoints);
      }
    }
  }, {
    key: "addAndEvictProxies",
    value: function addAndEvictProxies(proxy, evictedProxies) {
      var _this4 = this;

      //
      // Check if the proxy hasn't already been evicted by a
      // concurrent addProxies call. If it's the case, don't
      // add it to our local map.
      //
      var index = this._evictedIdentities.findIndex(function (e) {
        return e.equals(proxy.ice_getIdentity());
      });

      if (index >= 0) {
        this._evictedIdentities.splice(index, 1);
      } else {
        //
        // If we successfully added the proxy to the router,
        // we add it to our local map.
        //
        this._identities.set(proxy.ice_getIdentity(), 1);
      } //
      // We also must remove whatever proxies the router evicted.
      //


      evictedProxies.forEach(function (proxy) {
        _this4._identities.delete(proxy.ice_getIdentity());
      });
    }
  }]);

  return RouterInfo;
}();

Ice.RouterInfo = RouterInfo;
module.exports.Ice = Ice;