// **********************************************************************
//
// Copyright (c) 2003-present ZeroC, Inc. All rights reserved.
//
// **********************************************************************

import * as iceNS0 from "ice"

export namespace Ice {
    /**
     * A sequence of bools.
     */
    type BoolSeq = boolean[];

    class BoolSeqHelper {
        static write(outs: OutputStream, value: BoolSeq): void;
        static read(ins: InputStream): BoolSeq;
    }

    /**
     * A sequence of bytes.
     */
    type ByteSeq = Uint8Array;

    class ByteSeqHelper {
        static write(outs: OutputStream, value: ByteSeq): void;
        static read(ins: InputStream): ByteSeq;
    }

    /**
     * A sequence of shorts.
     */
    type ShortSeq = number[];

    class ShortSeqHelper {
        static write(outs: OutputStream, value: ShortSeq): void;
        static read(ins: InputStream): ShortSeq;
    }

    /**
     * A sequence of ints.
     */
    type IntSeq = number[];

    class IntSeqHelper {
        static write(outs: OutputStream, value: IntSeq): void;
        static read(ins: InputStream): IntSeq;
    }

    /**
     * A sequence of longs.
     */
    type LongSeq = Ice.Long[];

    class LongSeqHelper {
        static write(outs: OutputStream, value: LongSeq): void;
        static read(ins: InputStream): LongSeq;
    }

    /**
     * A sequence of floats.
     */
    type FloatSeq = number[];

    class FloatSeqHelper {
        static write(outs: OutputStream, value: FloatSeq): void;
        static read(ins: InputStream): FloatSeq;
    }

    /**
     * A sequence of doubles.
     */
    type DoubleSeq = number[];

    class DoubleSeqHelper {
        static write(outs: OutputStream, value: DoubleSeq): void;
        static read(ins: InputStream): DoubleSeq;
    }

    /**
     * A sequence of strings.
     */
    type StringSeq = string[];

    class StringSeqHelper {
        static write(outs: OutputStream, value: StringSeq): void;
        static read(ins: InputStream): StringSeq;
    }

    /**
     * A sequence of objects.
     */
    type ObjectSeq = Ice.Value[];

    class ObjectSeqHelper {
        static write(outs: OutputStream, value: ObjectSeq): void;
        static read(ins: InputStream): ObjectSeq;
    }

    /**
     * A sequence of object proxies.
     */
    type ObjectProxySeq = Ice.ObjectPrx[];

    class ObjectProxySeqHelper {
        static write(outs: OutputStream, value: ObjectProxySeq): void;
        static read(ins: InputStream): ObjectProxySeq;
    }
}

export namespace Ice {
    /**
     * The central object in Ice. One or more communicators can be
     * instantiated for an Ice application. Communicator instantiation
     * is language-specific, and not specified in Slice code.
     * @see Logger
     * @see ObjectAdapter
     * @see Properties
     * @see ValueFactory
     */
    interface Communicator {
        /**
         * Destroy the communicator. This operation calls {@link #shutdown}
         * implicitly.  Calling {@link #destroy} cleans up memory, and shuts down
         * this communicator's client functionality and destroys all object
         * adapters. Subsequent calls to {@link #destroy} are ignored.
         * @return @returns The asynchronous result object for the invocation.
         * @see #shutdown
         * @see ObjectAdapter#destroy
         */
        destroy(): AsyncResultBase<void>;
        /**
         * Shuts down this communicator's server functionality, which
         * includes the deactivation of all object adapters. Attempts to use a
         * deactivated object adapter raise ObjectAdapterDeactivatedException.
         * Subsequent calls to shutdown are ignored.
         *
         * After shutdown returns, no new requests are processed. However, requests
         * that have been started before shutdown was called might still be active.
         * You can use {@link #waitForShutdown} to wait for the completion of all
         * requests.
         * @return @returns The asynchronous result object for the invocation.
         * @see #destroy
         * @see #waitForShutdown
         * @see ObjectAdapter#deactivate
         */
        shutdown(): AsyncResultBase<void>;
        /**
         * Wait until the application has called {@link #shutdown} (or {@link #destroy}).
         * On the server side, this operation blocks the calling thread
         * until all currently-executing operations have completed.
         * On the client side, the operation simply blocks until another
         * thread has called {@link #shutdown} or {@link #destroy}.
         *
         * A typical use of this operation is to call it from the main thread,
         * which then waits until some other thread calls {@link #shutdown}.
         * After shut-down is complete, the main thread returns and can do some
         * cleanup work before it finally calls {@link #destroy} to shut down
         * the client functionality, and then exits the application.
         * @return @returns The asynchronous result object for the invocation.
         * @see #shutdown
         * @see #destroy
         * @see ObjectAdapter#waitForDeactivate
         */
        waitForShutdown(): AsyncResultBase<void>;
        /**
         * Check whether communicator has been shut down.
         * @return True if the communicator has been shut down; false otherwise.
         * @see #shutdown
         */
        isShutdown(): boolean;
        /**
         * Convert a stringified proxy into a proxy. For example,
         * <code>MyCategory/MyObject:tcp -h some_host -p
         * 10000</code> creates a proxy that refers to the Ice object
         * having an identity with a name "MyObject" and a category
         * "MyCategory", with the server running on host "some_host", port
         * 10000. If the stringified proxy does not parse correctly, the
         * operation throws one of ProxyParseException, EndpointParseException,
         * or IdentityParseException. Refer to the Ice manual for a detailed
         * description of the syntax supported by stringified proxies.
         * @param str The stringified proxy to convert into a proxy.
         * @return The proxy, or nil if <code>str</code> is an empty string.
         * @see #proxyToString
         */
        stringToProxy(str: string): Ice.ObjectPrx;
        /**
         * Convert a proxy into a string.
         * @param obj The proxy to convert into a stringified proxy.
         * @return The stringified proxy, or an empty string if
         * <code>obj</code> is nil.
         * @see #stringToProxy
         */
        proxyToString(obj: Ice.ObjectPrx): string;
        /**
         * Convert a set of proxy properties into a proxy. The "base"
         * name supplied in the <code>property</code> argument refers to a
         * property containing a stringified proxy, such as
         * <code>MyProxy=id:tcp -h localhost -p 10000</code>. Additional
         * properties configure local settings for the proxy, such as
         * <code>MyProxy.PreferSecure=1</code>. The "Properties"
         * appendix in the Ice manual describes each of the supported
         * proxy properties.
         * @param property The base property name.
         * @return The proxy.
         */
        propertyToProxy(property: string): Ice.ObjectPrx;
        /**
         * Convert a proxy to a set of proxy properties.
         * @param proxy The proxy.
         * @param property The base property name.
         * @return The property set.
         */
        proxyToProperty(proxy: Ice.ObjectPrx, property: string): PropertyDict;
        /**
         * Convert a string into an identity. If the string does not parse
         * correctly, the operation throws IdentityParseException.
         * @param str The string to convert into an identity.
         * @return The identity.
         * @see #identityToString
         *
         * @deprecated stringToIdentity() is deprecated, use the static stringToIdentity() method instead.
         */
        stringToIdentity(str: string): Identity;
        /**
         * Convert an identity into a string.
         * @param ident The identity to convert into a string.
         * @return The "stringified" identity.
         * @see #stringToIdentity
         */
        identityToString(ident: Identity): string;
        /**
         * Create a new object adapter. The endpoints for the object
         * adapter are taken from the property <code><em>name</em>.Endpoints</code>.
         *
         * It is legal to create an object adapter with the empty string as
         * its name. Such an object adapter is accessible via bidirectional
         * connections or by collocated invocations that originate from the
         * same communicator as is used by the adapter.
         *
         * Attempts to create a named object adapter for which no configuration
         * can be found raise InitializationException.
         * @param name The object adapter name.
         * @return @returns The asynchronous result object for the invocation.
         * @see #createObjectAdapterWithEndpoints
         * @see ObjectAdapter
         * @see Properties
         */
        createObjectAdapter(name: string): AsyncResultBase<Ice.ObjectAdapter>;
        /**
         * Create a new object adapter with endpoints. This operation sets
         * the property <code><em>name</em>.Endpoints</code>, and then calls
         * {@link #createObjectAdapter}. It is provided as a convenience
         * function.
         *
         * Calling this operation with an empty name will result in a
         * UUID being generated for the name.
         * @param name The object adapter name.
         * @param endpoints The endpoints for the object adapter.
         * @return @returns The asynchronous result object for the invocation.
         * @see #createObjectAdapter
         * @see ObjectAdapter
         * @see Properties
         */
        createObjectAdapterWithEndpoints(name: string, endpoints: string): AsyncResultBase<Ice.ObjectAdapter>;
        /**
         * Create a new object adapter with a router. This operation
         * creates a routed object adapter.
         *
         * Calling this operation with an empty name will result in a
         * UUID being generated for the name.
         * @param name The object adapter name.
         * @param rtr The router.
         * @return @returns The asynchronous result object for the invocation.
         * @see #createObjectAdapter
         * @see ObjectAdapter
         * @see Properties
         */
        createObjectAdapterWithRouter(name: string, rtr: RouterPrx): AsyncResultBase<Ice.ObjectAdapter>;
        /**
         * Add an object factory to this communicator. Installing a
         * factory with an id for which a factory is already registered
         * throws AlreadyRegisteredException.
         *
         * When unmarshaling an Ice object, the Ice run time reads the
         * most-derived type id off the wire and attempts to create an
         * instance of the type using a factory. If no instance is created,
         * either because no factory was found, or because all factories
         * returned nil, the behavior of the Ice run time depends on the
         * format with which the object was marshaled:
         *
         * If the object uses the "sliced" format, Ice ascends the class
         * hierarchy until it finds a type that is recognized by a factory,
         * or it reaches the least-derived type. If no factory is found that
         * can create an instance, the run time throws NoValueFactoryException.
         *
         * If the object uses the "compact" format, Ice immediately raises
         * NoValueFactoryException.
         *
         * The following order is used to locate a factory for a type:
         *
         * <ol>
         *
         * <li>The Ice run-time looks for a factory registered
         * specifically for the type.</li>
         *
         * <li>If no instance has been created, the Ice run-time looks
         * for the default factory, which is registered with an empty type id.
         * </li>
         *
         * <li>If no instance has been created by any of the preceding
         * steps, the Ice run-time looks for a factory that may have been
         * statically generated by the language mapping for non-abstract classes.
         * </li>
         *
         * </ol>
         * @param factory The factory to add.
         * @param id The type id for which the factory can create instances, or
         * an empty string for the default factory.
         * @see #findObjectFactory
         * @see ObjectFactory
         * @see ValueFactoryManager#add
         *
         * @deprecated addObjectFactory() is deprecated, use ValueFactoryManager::add() instead.
         */
        addObjectFactory(factory: Ice.ObjectFactory, id: string): void;
        /**
         * Find an object factory registered with this communicator.
         * @param id The type id for which the factory can create instances,
         * or an empty string for the default factory.
         * @return The object factory, or null if no object factory was
         * found for the given id.
         * @see #addObjectFactory
         * @see ObjectFactory
         * @see ValueFactoryManager#find
         *
         * @deprecated findObjectFactory() is deprecated, use ValueFactoryManager::find() instead.
         */
        findObjectFactory(id: string): Ice.ObjectFactory;
        /**
         * Get the implicit context associated with this communicator.
         * @return The implicit context associated with this communicator;
         * returns null when the property Ice.ImplicitContext is not set
         * or is set to None.
         */
        getImplicitContext(): Ice.ImplicitContext;
        /**
         * Get the properties for this communicator.
         * @return This communicator's properties.
         * @see Properties
         */
        getProperties(): Ice.Properties;
        /**
         * Get the logger for this communicator.
         * @return This communicator's logger.
         * @see Logger
         */
        getLogger(): Ice.Logger;
        /**
         * Get the default router this communicator.
         * @return The default router for this communicator.
         * @see #setDefaultRouter
         * @see Router
         */
        getDefaultRouter(): RouterPrx;
        /**
         * Set a default router for this communicator. All newly
         * created proxies will use this default router. To disable the
         * default router, null can be used. Note that this
         * operation has no effect on existing proxies.
         *
         * You can also set a router for an individual proxy
         * by calling the operation <code>ice_router</code> on the proxy.
         * @param rtr The default router to use for this communicator.
         * @see #getDefaultRouter
         * @see #createObjectAdapterWithRouter
         * @see Router
         */
        setDefaultRouter(rtr: RouterPrx): void;
        /**
         * Get the default locator this communicator.
         * @return The default locator for this communicator.
         * @see #setDefaultLocator
         * @see Locator
         */
        getDefaultLocator(): LocatorPrx;
        /**
         * Set a default Ice locator for this communicator. All newly
         * created proxy and object adapters will use this default
         * locator. To disable the default locator, null can be used.
         * Note that this operation has no effect on existing proxies or
         * object adapters.
         *
         * You can also set a locator for an individual proxy by calling the
         * operation <code>ice_locator</code> on the proxy, or for an object adapter
         * by calling {@link ObjectAdapter#setLocator} on the object adapter.
         * @param loc The default locator to use for this communicator.
         * @see #getDefaultLocator
         * @see Locator
         * @see ObjectAdapter#setLocator
         */
        setDefaultLocator(loc: LocatorPrx): void;
        /**
         * Get the value factory manager for this communicator.
         * @return This communicator's value factory manager.
         * @see ValueFactoryManager
         */
        getValueFactoryManager(): Ice.ValueFactoryManager;
        /**
         * Flush any pending batch requests for this communicator.
         * This means all batch requests invoked on fixed proxies
         * for all connections associated with the communicator.
         * Any errors that occur while flushing a connection are ignored.
         * @param compress Specifies whether or not the queued batch requests
         * should be compressed before being sent over the wire.
         * @return @returns The asynchronous result object for the invocation.
         */
        flushBatchRequests(compress: CompressBatch): AsyncResultBase<void>;
    }

    /**
     * The output mode for xxxToString method such as identityToString and proxyToString.
     * The actual encoding format for the string is the same for all modes: you
     * don't need to specify an encoding format or mode when reading such a string.
     */
    class ToStringMode {
        /**
         * Characters with ordinal values greater than 127 are kept as-is in the resulting string.
         * Non-printable ASCII characters with ordinal values 127 and below are encoded as \\t, \\n (etc.)
         * or \\unnnn.
         */
        static readonly Unicode: ToStringMode;
        /**
         * Characters with ordinal values greater than 127 are encoded as universal character names in
         * the resulting string: \\unnnn for BMP characters and \\Unnnnnnnn for non-BMP characters.
         * Non-printable ASCII characters with ordinal values 127 and below are encoded as \\t, \\n (etc.)
         * or \\unnnn.
         */
        static readonly ASCII: ToStringMode;
        /**
         * Characters with ordinal values greater than 127 are encoded as a sequence of UTF-8 bytes using
         * octal escapes. Characters with ordinal values 127 and below are encoded as \\t, \\n (etc.) or
         * an octal escape. Use this mode to generate strings compatible with Ice 3.6 and earlier.
         */
        static readonly Compat: ToStringMode;

        static valueOf(value: number): ToStringMode;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }
}

export namespace Ice {
}

export namespace Ice {
    /**
     * The batch compression option when flushing queued batch requests.
     */
    class CompressBatch {
        /**
         * Compress the batch requests.
         */
        static readonly Yes: CompressBatch;
        /**
         * Don't compress the batch requests.
         */
        static readonly No: CompressBatch;
        /**
         * Compress the batch requests if at least one request was
         * made on a compressed proxy.
         */
        static readonly BasedOnProxy: CompressBatch;

        static valueOf(value: number): CompressBatch;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * Base class providing access to the connection details.
     */
    class ConnectionInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling transport or null if there's no underlying transport.
         * @param incoming Whether or not the connection is an incoming or outgoing connection.
         * @param adapterName The name of the adapter associated with the connection.
         * @param connectionId The connection id.
         */
        constructor(underlying?: Ice.ConnectionInfo, incoming?: boolean, adapterName?: string, connectionId?: string);
        /**
         * The information of the underyling transport or null if there's
         * no underlying transport.
         */
        underlying: Ice.ConnectionInfo;
        /**
         * Whether or not the connection is an incoming or outgoing
         * connection.
         */
        incoming: boolean;
        /**
         * The name of the adapter associated with the connection.
         */
        adapterName: string;
        /**
         * The connection id.
         */
        connectionId: string;
    }
    /**
     * This method is called by the the connection when the connection
     * is closed. If the callback needs more information about the closure,
     * it can call {@link Connection#throwException}.
     * @param con The connection that closed.
     */
    type CloseCallback = (con: Ice.Connection) => void;
    /**
     * This method is called by the the connection when a heartbeat is
     * received from the peer.
     * @param con The connection on which a heartbeat was received.
     */
    type HeartbeatCallback = (con: Ice.Connection) => void;

    /**
     * Specifies the close semantics for Active Connection Management.
     */
    class ACMClose {
        /**
         * Disables automatic connection closure.
         */
        static readonly CloseOff: ACMClose;
        /**
         * Gracefully closes a connection that has been idle for the configured timeout period.
         */
        static readonly CloseOnIdle: ACMClose;
        /**
         * Forcefully closes a connection that has been idle for the configured timeout period,
         * but only if the connection has pending invocations.
         */
        static readonly CloseOnInvocation: ACMClose;
        /**
         * Combines the behaviors of CloseOnIdle and CloseOnInvocation.
         */
        static readonly CloseOnInvocationAndIdle: ACMClose;
        /**
         * Forcefully closes a connection that has been idle for the configured timeout period,
         * regardless of whether the connection has pending invocations or dispatch.
         */
        static readonly CloseOnIdleForceful: ACMClose;

        static valueOf(value: number): ACMClose;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * Specifies the heartbeat semantics for Active Connection Management.
     */
    class ACMHeartbeat {
        /**
         * Disables heartbeats.
         */
        static readonly HeartbeatOff: ACMHeartbeat;
        /**
         * Send a heartbeat at regular intervals if the connection is idle and only if there are pending dispatch.
         */
        static readonly HeartbeatOnDispatch: ACMHeartbeat;
        /**
         * Send a heartbeat at regular intervals when the connection is idle.
         */
        static readonly HeartbeatOnIdle: ACMHeartbeat;
        /**
         * Send a heartbeat at regular intervals until the connection is closed.
         */
        static readonly HeartbeatAlways: ACMHeartbeat;

        static valueOf(value: number): ACMHeartbeat;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * A collection of Active Connection Management configuration settings.
     */
    class ACM {
        constructor(timeout?: number, close?: ACMClose, heartbeat?: ACMHeartbeat);
        clone(): ACM;
        equals(rhs: any): boolean;
        hashCode(): number;
        timeout: number;
        close: ACMClose;
        heartbeat: ACMHeartbeat;
        static write(outs: OutputStream, value: ACM): void;
        static read(ins: InputStream): ACM;
    }

    /**
     * Determines the behavior when manually closing a connection.
     */
    class ConnectionClose {
        /**
         * Close the connection immediately without sending a close connection protocol message to the peer
         * and waiting for the peer to acknowledge it.
         */
        static readonly Forcefully: ConnectionClose;
        /**
         * Close the connection by notifying the peer but do not wait for pending outgoing invocations to complete.
         * On the server side, the connection will not be closed until all incoming invocations have completed.
         */
        static readonly Gracefully: ConnectionClose;
        /**
         * Wait for all pending invocations to complete before closing the connection.
         */
        static readonly GracefullyWithWait: ConnectionClose;

        static valueOf(value: number): ConnectionClose;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * The user-level interface to a connection.
     */
    interface Connection {
        /**
         * Manually close the connection using the specified closure mode.
         * @param mode Determines how the connection will be closed.
         * @return @returns The asynchronous result object for the invocation.
         * @see ConnectionClose
         */
        close(mode: ConnectionClose): AsyncResultBase<void>;
        /**
         * Create a special proxy that always uses this connection. This
         * can be used for callbacks from a server to a client if the
         * server cannot directly establish a connection to the client,
         * for example because of firewalls. In this case, the server
         * would create a proxy using an already established connection
         * from the client.
         * @param id The identity for which a proxy is to be created.
         * @return A proxy that matches the given identity and uses this
         * connection.
         * @see #setAdapter
         */
        createProxy(id: Identity): Ice.ObjectPrx;
        /**
         * Explicitly set an object adapter that dispatches requests that
         * are received over this connection. A client can invoke an
         * operation on a server using a proxy, and then set an object
         * adapter for the outgoing connection that is used by the proxy
         * in order to receive callbacks. This is useful if the server
         * cannot establish a connection back to the client, for example
         * because of firewalls.
         * @param adapter The object adapter that should be used by this
         * connection to dispatch requests. The object adapter must be
         * activated. When the object adapter is deactivated, it is
         * automatically removed from the connection. Attempts to use a
         * deactivated object adapter raise {@link ObjectAdapterDeactivatedException}
         * @see #createProxy
         * @see #getAdapter
         */
        setAdapter(adapter: Ice.ObjectAdapter): void;
        /**
         * Get the object adapter that dispatches requests for this
         * connection.
         * @return The object adapter that dispatches requests for the
         * connection, or null if no adapter is set.
         * @see #setAdapter
         */
        getAdapter(): Ice.ObjectAdapter;
        /**
         * Get the endpoint from which the connection was created.
         * @return The endpoint from which the connection was created.
         */
        getEndpoint(): Ice.Endpoint;
        /**
         * Flush any pending batch requests for this connection.
         * This means all batch requests invoked on fixed proxies
         * associated with the connection.
         * @param compress Specifies whether or not the queued batch requests
         * should be compressed before being sent over the wire.
         * @return @returns The asynchronous result object for the invocation.
         */
        flushBatchRequests(compress: CompressBatch): AsyncResultBase<void>;
        /**
         * Set a close callback on the connection. The callback is called by the
         * connection when it's closed. The callback is called from the
         * Ice thread pool associated with the connection. If the callback needs
         * more information about the closure, it can call {@link Connection#throwException}.
         * @param callback The close callback object.
         */
        setCloseCallback(callback: Ice.CloseCallback): void;
        /**
         * Set a heartbeat callback on the connection. The callback is called by the
         * connection when a heartbeat is received. The callback is called
         * from the Ice thread pool associated with the connection.
         * @param callback The heartbeat callback object.
         */
        setHeartbeatCallback(callback: Ice.HeartbeatCallback): void;
        /**
         * Send a heartbeat message.
         * @return @returns The asynchronous result object for the invocation.
         */
        heartbeat(): AsyncResultBase<void>;
        /**
         * Set the active connection management parameters.
         * @param timeout The timeout value in seconds. It must be positive or 0, if a negative
         * value is given, an invalid argument exception will be raised.
         * @param close The close condition
         * @param heartbeat The hertbeat condition
         */
        setACM(timeout: number, close: ACMClose, heartbeat: ACMHeartbeat): void;
        /**
         * Get the ACM parameters.
         * @return The ACM parameters.
         */
        getACM(): ACM;
        /**
         * Return the connection type. This corresponds to the endpoint
         * type, i.e., "tcp", "udp", etc.
         * @return The type of the connection.
         */
        type(): string;
        /**
         * Get the timeout for the connection.
         * @return The connection's timeout.
         */
        timeout(): number;
        /**
         * Return a description of the connection as human readable text,
         * suitable for logging or error messages.
         * @return The description of the connection as human readable
         * text.
         */
        toString(): string;
        /**
         * Returns the connection information.
         * @return The connection information.
         */
        getInfo(): Ice.ConnectionInfo;
        /**
         * Set the connection buffer receive/send size.
         * @param rcvSize The connection receive buffer size.
         * @param sndSize The connection send buffer size.
         */
        setBufferSize(rcvSize: number, sndSize: number): void;
        /**
         * Throw an exception indicating the reason for connection closure. For example,
         * {@link CloseConnectionException} is raised if the connection was closed gracefully,
         * whereas {@link ConnectionManuallyClosedException} is raised if the connection was
         * manually closed by the application. This operation does nothing if the connection is
         * not yet closed.
         */
        throwException(): void;
    }

    /**
     * Provides access to the connection details of an IP connection
     */
    class IPConnectionInfo extends ConnectionInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling transport or null if there's no underlying transport.
         * @param incoming Whether or not the connection is an incoming or outgoing connection.
         * @param adapterName The name of the adapter associated with the connection.
         * @param connectionId The connection id.
         * @param localAddress The local address.
         * @param localPort The local port.
         * @param remoteAddress The remote address.
         * @param remotePort The remote port.
         */
        constructor(underlying?: Ice.ConnectionInfo, incoming?: boolean, adapterName?: string, connectionId?: string, localAddress?: string, localPort?: number, remoteAddress?: string, remotePort?: number);
        /**
         * The local address.
         */
        localAddress: string;
        /**
         * The local port.
         */
        localPort: number;
        /**
         * The remote address.
         */
        remoteAddress: string;
        /**
         * The remote port.
         */
        remotePort: number;
    }

    /**
     * Provides access to the connection details of a TCP connection
     */
    class TCPConnectionInfo extends IPConnectionInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling transport or null if there's no underlying transport.
         * @param incoming Whether or not the connection is an incoming or outgoing connection.
         * @param adapterName The name of the adapter associated with the connection.
         * @param connectionId The connection id.
         * @param localAddress The local address.
         * @param localPort The local port.
         * @param remoteAddress The remote address.
         * @param remotePort The remote port.
         * @param rcvSize The connection buffer receive size.
         * @param sndSize The connection buffer send size.
         */
        constructor(underlying?: Ice.ConnectionInfo, incoming?: boolean, adapterName?: string, connectionId?: string, localAddress?: string, localPort?: number, remoteAddress?: string, remotePort?: number, rcvSize?: number, sndSize?: number);
        /**
         * The connection buffer receive size.
         */
        rcvSize: number;
        /**
         * The connection buffer send size.
         */
        sndSize: number;
    }

    /**
     * Provides access to the connection details of a UDP connection
     */
    class UDPConnectionInfo extends IPConnectionInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling transport or null if there's no underlying transport.
         * @param incoming Whether or not the connection is an incoming or outgoing connection.
         * @param adapterName The name of the adapter associated with the connection.
         * @param connectionId The connection id.
         * @param localAddress The local address.
         * @param localPort The local port.
         * @param remoteAddress The remote address.
         * @param remotePort The remote port.
         * @param mcastAddress The multicast address.
         * @param mcastPort The multicast port.
         * @param rcvSize The connection buffer receive size.
         * @param sndSize The connection buffer send size.
         */
        constructor(underlying?: Ice.ConnectionInfo, incoming?: boolean, adapterName?: string, connectionId?: string, localAddress?: string, localPort?: number, remoteAddress?: string, remotePort?: number, mcastAddress?: string, mcastPort?: number, rcvSize?: number, sndSize?: number);
        /**
         * The multicast address.
         */
        mcastAddress: string;
        /**
         * The multicast port.
         */
        mcastPort: number;
        /**
         * The connection buffer receive size.
         */
        rcvSize: number;
        /**
         * The connection buffer send size.
         */
        sndSize: number;
    }

    /**
     * A collection of HTTP headers.
     */
    class HeaderDict extends Map<string, string>
    {
    }

    class HeaderDictHelper {
        static write(outs: OutputStream, value: HeaderDict): void;
        static read(ins: InputStream): HeaderDict;
    }

    /**
     * Provides access to the connection details of a WebSocket connection
     */
    class WSConnectionInfo extends ConnectionInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling transport or null if there's no underlying transport.
         * @param incoming Whether or not the connection is an incoming or outgoing connection.
         * @param adapterName The name of the adapter associated with the connection.
         * @param connectionId The connection id.
         * @param headers The headers from the HTTP upgrade request.
         */
        constructor(underlying?: Ice.ConnectionInfo, incoming?: boolean, adapterName?: string, connectionId?: string, headers?: HeaderDict);
        /**
         * The headers from the HTTP upgrade request.
         */
        headers: HeaderDict;
    }
}

export namespace Ice {
}

export namespace IceSSL {
    /**
     * Provides access to the connection details of an SSL connection
     */
    class ConnectionInfo extends Ice.ConnectionInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling transport or null if there's no underlying transport.
         * @param incoming Whether or not the connection is an incoming or outgoing connection.
         * @param adapterName The name of the adapter associated with the connection.
         * @param connectionId The connection id.
         * @param cipher The negotiated cipher suite.
         * @param certs The certificate chain.
         * @param verified The certificate chain verification status.
         */
        constructor(underlying?: Ice.ConnectionInfo, incoming?: boolean, adapterName?: string, connectionId?: string, cipher?: string, certs?: Ice.StringSeq, verified?: boolean);
        /**
         * The negotiated cipher suite.
         */
        cipher: string;
        /**
         * The certificate chain.
         */
        certs: Ice.StringSeq;
        /**
         * The certificate chain verification status.
         */
        verified: boolean;
    }
}

export namespace Ice {
    /**
     * A request context. <code>Context</code> is used to transmit metadata about a
     * request from the server to the client, such as Quality-of-Service
     * (QoS) parameters. Each operation on the client has a <code>Context</code> as
     * its implicit final parameter.
     */
    class Context extends Map<string, string>
    {
    }

    class ContextHelper {
        static write(outs: OutputStream, value: Context): void;
        static read(ins: InputStream): Context;
    }

    /**
     * Determines the retry behavior an invocation in case of a (potentially) recoverable error.
     */
    class OperationMode {
        /**
         * Ordinary operations have <code>Normal</code> mode.  These operations
         * modify object state; invoking such an operation twice in a row
         * has different semantics than invoking it once. The Ice run time
         * guarantees that it will not violate at-most-once semantics for
         * <code>Normal</code> operations.
         */
        static readonly Normal: OperationMode;
        /**
         * Operations that use the Slice <code>nonmutating</code> keyword must not
         * modify object state. For C++, nonmutating operations generate
         * <code>const</code> member functions in the skeleton. In addition, the Ice
         * run time will attempt to transparently recover from certain
         * run-time errors by re-issuing a failed request and propagate
         * the failure to the application only if the second attempt
         * fails.
         *
         * <p class="Deprecated"><code>Nonmutating</code> is deprecated; Use the
         * <code>idempotent</code> keyword instead. For C++, to retain the mapping
         * of <code>nonmutating</code> operations to C++ <code>const</code>
         * member functions, use the <code>\["cpp:const"]</code> metadata
         * directive.
         */
        static readonly Nonmutating: OperationMode;
        /**
         * Operations that use the Slice <code>idempotent</code> keyword can modify
         * object state, but invoking an operation twice in a row must
         * result in the same object state as invoking it once.  For
         * example, <code>x = 1</code> is an idempotent statement,
         * whereas <code>x += 1</code> is not. For idempotent
         * operations, the Ice run-time uses the same retry behavior
         * as for nonmutating operations in case of a potentially
         * recoverable error.
         */
        static readonly Idempotent: OperationMode;

        static valueOf(value: number): OperationMode;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * Information about the current method invocation for servers. Each
     * operation on the server has a <code>Current</code> as its implicit final
     * parameter. <code>Current</code> is mostly used for Ice services. Most
     * applications ignore this parameter.
     */
    class Current {
        constructor(adapter?: Ice.ObjectAdapter, con?: Ice.Connection, id?: Identity, facet?: string, operation?: string, mode?: OperationMode, ctx?: Context, requestId?: number, encoding?: EncodingVersion);
        clone(): Current;
        equals(rhs: any): boolean;
        adapter: Ice.ObjectAdapter;
        con: Ice.Connection;
        id: Identity;
        facet: string;
        operation: string;
        mode: OperationMode;
        ctx: Context;
        requestId: number;
        encoding: EncodingVersion;
        static write(outs: OutputStream, value: Current): void;
        static read(ins: InputStream): Current;
    }
}

export namespace Ice {
    /**
     * Uniquely identifies TCP endpoints.
     */
    const TCPEndpointType: number;

    /**
     * Uniquely identifies SSL endpoints.
     */
    const SSLEndpointType: number;

    /**
     * Uniquely identifies UDP endpoints.
     */
    const UDPEndpointType: number;

    /**
     * Uniquely identifies TCP-based WebSocket endpoints.
     */
    const WSEndpointType: number;

    /**
     * Uniquely identifies SSL-based WebSocket endpoints.
     */
    const WSSEndpointType: number;

    /**
     * Uniquely identifies Bluetooth endpoints.
     */
    const BTEndpointType: number;

    /**
     * Uniquely identifies SSL Bluetooth endpoints.
     */
    const BTSEndpointType: number;

    /**
     * Uniquely identifies iAP-based endpoints.
     */
    const iAPEndpointType: number;

    /**
     * Uniquely identifies SSL iAP-based endpoints.
     */
    const iAPSEndpointType: number;

    /**
     * Base class providing access to the endpoint details.
     */
    class EndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean);
        /**
         * The information of the underyling endpoint of null if there's
         * no underlying endpoint.
         */
        underlying: Ice.EndpointInfo;
        /**
         * The timeout for the endpoint in milliseconds. 0 means
         * non-blocking, -1 means no timeout.
         */
        timeout: number;
        /**
         * Specifies whether or not compression should be used if
         * available when using this endpoint.
         */
        compress: boolean;
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }

    /**
     * The user-level interface to an endpoint.
     */
    interface Endpoint {
        /**
         * Return a string representation of the endpoint.
         * @return The string representation of the endpoint.
         */
        toString(): string;
        /**
         * Returns the endpoint information.
         * @return The endpoint information class.
         */
        getInfo(): Ice.EndpointInfo;
        equals(rhs: any): boolean
    }

    /**
     * Provides access to the address details of a IP endpoint.
     * @see Endpoint
     */
    class IPEndpointInfo extends EndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         * @param host The host or address configured with the endpoint.
         * @param port The port number.
         * @param sourceAddress The source IP address.
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean, host?: string, port?: number, sourceAddress?: string);
        /**
         * The host or address configured with the endpoint.
         */
        host: string;
        /**
         * The port number.
         */
        port: number;
        /**
         * The source IP address.
         */
        sourceAddress: string;
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }

    /**
     * Provides access to a TCP endpoint information.
     * @see Endpoint
     */
    class TCPEndpointInfo extends IPEndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         * @param host The host or address configured with the endpoint.
         * @param port The port number.
         * @param sourceAddress The source IP address.
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean, host?: string, port?: number, sourceAddress?: string);
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }

    /**
     * Provides access to an UDP endpoint information.
     * @see Endpoint
     */
    class UDPEndpointInfo extends IPEndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         * @param host The host or address configured with the endpoint.
         * @param port The port number.
         * @param sourceAddress The source IP address.
         * @param mcastInterface The multicast interface.
         * @param mcastTtl The multicast time-to-live (or hops).
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean, host?: string, port?: number, sourceAddress?: string, mcastInterface?: string, mcastTtl?: number);
        /**
         * The multicast interface.
         */
        mcastInterface: string;
        /**
         * The multicast time-to-live (or hops).
         */
        mcastTtl: number;
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }

    /**
     * Provides access to a WebSocket endpoint information.
     */
    class WSEndpointInfo extends EndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         * @param resource The URI configured with the endpoint.
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean, resource?: string);
        /**
         * The URI configured with the endpoint.
         */
        resource: string;
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }

    /**
     * Provides access to the details of an opaque endpoint.
     * @see Endpoint
     */
    class OpaqueEndpointInfo extends EndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         * @param rawEncoding The encoding version of the opaque endpoint (to decode or encode the rawBytes).
         * @param rawBytes The raw encoding of the opaque endpoint.
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean, rawEncoding?: EncodingVersion, rawBytes?: ByteSeq);
        /**
         * The encoding version of the opaque endpoint (to decode or
         * encode the rawBytes).
         */
        rawEncoding: EncodingVersion;
        /**
         * The raw encoding of the opaque endpoint.
         */
        rawBytes: ByteSeq;
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }
}

export namespace Ice {
    /**
     * A sequence of endpoints.
     */
    type EndpointSeq = Ice.Endpoint[];

    class EndpointSeqHelper {
        static write(outs: OutputStream, value: EndpointSeq): void;
        static read(ins: InputStream): EndpointSeq;
    }
}

export namespace IceSSL {
    /**
     * Provides access to an SSL endpoint information.
     */
    class EndpointInfo extends Ice.EndpointInfo {
        /**
         * One-shot constructor to initialize all data members.
         * @param underlying The information of the underyling endpoint of null if there's no underlying endpoint.
         * @param timeout The timeout for the endpoint in milliseconds.
         * @param compress Specifies whether or not compression should be used if available when using this endpoint.
         */
        constructor(underlying?: Ice.EndpointInfo, timeout?: number, compress?: boolean);
        /**
         * Returns the type of the endpoint.
         * @return The endpoint type.
         */
        type(): number;
        /**
         * Returns true if this endpoint is a datagram endpoint.
         * @return True for a datagram endpoint.
         */
        datagram(): boolean;
        /**
         * Returns true if this endpoint is a secure endpoint.
         * @return True for a secure endpoint.
         */
        secure(): boolean;
    }
}

export namespace Ice {
    /**
     * Determines the order in which the Ice run time uses the endpoints
     * in a proxy when establishing a connection.
     */
    class EndpointSelectionType {
        /**
         * <code>Random</code> causes the endpoints to be arranged in a random order.
         */
        static readonly Random: EndpointSelectionType;
        /**
         * <code>Ordered</code> forces the Ice run time to use the endpoints in the
         * order they appeared in the proxy.
         */
        static readonly Ordered: EndpointSelectionType;

        static valueOf(value: number): EndpointSelectionType;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }
}

export namespace Ice {
    /**
     * A mapping from facet name to servant.
     */
    class FacetMap extends Map<string, Ice.Object>
    {
    }

    class FacetMapHelper {
        static write(outs: OutputStream, value: FacetMap): void;
        static read(ins: InputStream): FacetMap;
    }
}

export namespace Ice {
    /**
     * The identity of an Ice object. In a proxy, an empty {@link Identity#name} denotes a nil
     * proxy. An identity with an empty {@link Identity#name} and a non-empty {@link Identity#category}
     * is illegal. You cannot add a servant with an empty name to the Active Servant Map.
     * @see ServantLocator
     * @see ObjectAdapter#addServantLocator
     */
    class Identity {
        constructor(name?: string, category?: string);
        clone(): Identity;
        equals(rhs: any): boolean;
        hashCode(): number;
        name: string;
        category: string;
        static write(outs: OutputStream, value: Identity): void;
        static read(ins: InputStream): Identity;
    }

    /**
     * A mapping between identities and Ice objects.
     */
    class ObjectDict extends HashMap<Identity, Ice.Object>
    {
    }

    class ObjectDictHelper {
        static write(outs: OutputStream, value: ObjectDict): void;
        static read(ins: InputStream): ObjectDict;
    }

    /**
     * A sequence of identities.
     */
    type IdentitySeq = Identity[];

    class IdentitySeqHelper {
        static write(outs: OutputStream, value: IdentitySeq): void;
        static read(ins: InputStream): IdentitySeq;
    }
}

export namespace Ice {
    /**
     * An interface to associate implict contexts with communicators.
     *
     * When you make a remote invocation without an explicit context parameter,
     * Ice uses the per-proxy context (if any) combined with the <code>ImplicitContext</code>
     * associated with the communicator.
     *
     * Ice provides several implementations of <code>ImplicitContext</code>. The implementation
     * used depends on the value of the <code>Ice.ImplicitContext</code> property.
     * <dl>
     * <dt><code>None</code> (default)</dt>
     * <dd>No implicit context at all.</dd>
     * <dt><code>PerThread</code></dt>
     * <dd>The implementation maintains a context per thread.</dd>
     * <dt><code>Shared</code></dt>
     * <dd>The implementation maintains a single context shared by all threads.</dd>
     * </dl>
     *
     * <code>ImplicitContext</code> also provides a number of operations to create, update or retrieve
     * an entry in the underlying context without first retrieving a copy of the entire
     * context. These operations correspond to a subset of the <code>java.util.Map</code> methods,
     * with <code>java.lang.Object</code> replaced by <code>string</code> and null replaced by the empty-string.
     */
    interface ImplicitContext {
        /**
         * Get a copy of the underlying context.
         * @return A copy of the underlying context.
         */
        getContext(): Context;
        /**
         * Set the underlying context.
         * @param newContext The new context.
         */
        setContext(newContext: Context): void;
        /**
         * Check if this key has an associated value in the underlying context.
         * @param key The key.
         * @return True if the key has an associated value, False otherwise.
         */
        containsKey(key: string): boolean;
        /**
         * Get the value associated with the given key in the underlying context.
         * Returns an empty string if no value is associated with the key.
         * {@link #containsKey} allows you to distinguish between an empty-string value and
         * no value at all.
         * @param key The key.
         * @return The value associated with the key.
         */
        get(key: string): string;
        /**
         * Create or update a key/value entry in the underlying context.
         * @param key The key.
         * @param value The value.
         * @return The previous value associated with the key, if any.
         */
        put(key: string, value: string): string;
        /**
         * Remove the entry for the given key in the underlying context.
         * @param key The key.
         * @return The value associated with the key, if any.
         */
        remove(key: string): string;
    }
}

export namespace Ice {
}

export namespace Ice {
    namespace Instrumentation {
    }
}

export namespace Ice {
    /**
     * This exception is raised when a failure occurs during initialization.
     */
    class InitializationException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception indicates that a failure occurred while initializing
     * a plug-in.
     */
    class PluginInitializationException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception is raised if a feature is requested that is not
     * supported with collocation optimization.
     *
     * @deprecated This exception is no longer used by the Ice run time
     */
    class CollocationOptimizationException extends LocalException {
    }

    /**
     * An attempt was made to register something more than once with
     * the Ice run time.
     *
     * This exception is raised if an attempt is made to register a
     * servant, servant locator, facet, value factory, plug-in, object
     * adapter, object, or user exception factory more than once for the
     * same ID.
     */
    class AlreadyRegisteredException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param kindOfObject The kind of object that could not be removed: "servant", "facet", "object", "default servant", "servant locator", "value factory", "plugin", "object adapter", "object adapter with router", "replica group".
         * @param id The ID (or name) of the object that is registered already.
         * @param ice_cause The error that cause this exception.
         */
        constructor(kindOfObject?: string, id?: string, ice_cause?: string | Error);
        kindOfObject: string;
        id: string;
    }

    /**
     * An attempt was made to find or deregister something that is not
     * registered with the Ice run time or Ice locator.
     *
     * This exception is raised if an attempt is made to remove a servant,
     * servant locator, facet, value factory, plug-in, object adapter,
     * object, or user exception factory that is not currently registered.
     *
     * It's also raised if the Ice locator can't find an object or object
     * adapter when resolving an indirect proxy or when an object adapter
     * is activated.
     */
    class NotRegisteredException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param kindOfObject The kind of object that could not be removed: "servant", "facet", "object", "default servant", "servant locator", "value factory", "plugin", "object adapter", "object adapter with router", "replica group".
         * @param id The ID (or name) of the object that could not be removed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(kindOfObject?: string, id?: string, ice_cause?: string | Error);
        kindOfObject: string;
        id: string;
    }

    /**
     * The operation can only be invoked with a twoway request.
     *
     * This exception is raised if an attempt is made to invoke an
     * operation with <code>ice_oneway</code>, <code>ice_batchOneway</code>, <code>ice_datagram</code>,
     * or <code>ice_batchDatagram</code> and the operation has a return value,
     * out-parameters, or an exception specification.
     */
    class TwowayOnlyException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param operation The name of the operation that was invoked.
         * @param ice_cause The error that cause this exception.
         */
        constructor(operation?: string, ice_cause?: string | Error);
        operation: string;
    }

    /**
     * An attempt was made to clone a class that does not support
     * cloning.
     *
     * This exception is raised if <code>ice_clone</code> is called on
     * a class that is derived from an abstract Slice class (that is,
     * a class containing operations), and the derived class does not
     * provide an implementation of the <code>ice_clone</code> operation (C++ only).
     */
    class CloneNotImplementedException extends LocalException {
    }

    /**
     * This exception is raised if an operation call on a server raises an
     * unknown exception. For example, for C++, this exception is raised
     * if the server throws a C++ exception that is not directly or
     * indirectly derived from <code>Ice::LocalException</code> or
     * <code>Ice::UserException</code>.
     */
    class UnknownException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param unknown This field is set to the textual representation of the unknown exception if available.
         * @param ice_cause The error that cause this exception.
         */
        constructor(unknown?: string, ice_cause?: string | Error);
        unknown: string;
    }

    /**
     * This exception is raised if an operation call on a server raises a
     * local exception. Because local exceptions are not transmitted by
     * the Ice protocol, the client receives all local exceptions raised
     * by the server as {@link UnknownLocalException}. The only exception to this
     * rule are all exceptions derived from {@link RequestFailedException},
     * which are transmitted by the Ice protocol even though they are
     * declared <code>local</code>.
     */
    class UnknownLocalException extends UnknownException {
        /**
         * One-shot constructor to initialize all data members.
         * @param unknown This field is set to the textual representation of the unknown exception if available.
         * @param ice_cause The error that cause this exception.
         */
        constructor(unknown?: string, ice_cause?: string | Error);
    }

    /**
     * An operation raised an incorrect user exception.
     *
     * This exception is raised if an operation raises a
     * user exception that is not declared in the exception's
     * <code>throws</code> clause. Such undeclared exceptions are
     * not transmitted from the server to the client by the Ice
     * protocol, but instead the client just gets an
     * {@link UnknownUserException}. This is necessary in order to not violate
     * the contract established by an operation's signature: Only local
     * exceptions and user exceptions declared in the
     * <code>throws</code> clause can be raised.
     */
    class UnknownUserException extends UnknownException {
        /**
         * One-shot constructor to initialize all data members.
         * @param unknown This field is set to the textual representation of the unknown exception if available.
         * @param ice_cause The error that cause this exception.
         */
        constructor(unknown?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if the Ice library version does not match
     * the version in the Ice header files.
     */
    class VersionMismatchException extends LocalException {
    }

    /**
     * This exception is raised if the {@link Communicator} has been destroyed.
     * @see Communicator#destroy
     */
    class CommunicatorDestroyedException extends LocalException {
    }

    /**
     * This exception is raised if an attempt is made to use a deactivated
     * {@link ObjectAdapter}.
     * @see ObjectAdapter#deactivate
     * @see Communicator#shutdown
     */
    class ObjectAdapterDeactivatedException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name Name of the adapter.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * This exception is raised if an {@link ObjectAdapter} cannot be activated.
     *
     * This happens if the {@link Locator} detects another active {@link ObjectAdapter} with
     * the same adapter id.
     */
    class ObjectAdapterIdInUseException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id Adapter ID.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: string, ice_cause?: string | Error);
        id: string;
    }

    /**
     * This exception is raised if no suitable endpoint is available.
     */
    class NoEndpointException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param proxy The stringified proxy for which no suitable endpoint is available.
         * @param ice_cause The error that cause this exception.
         */
        constructor(proxy?: string, ice_cause?: string | Error);
        proxy: string;
    }

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint.
     */
    class EndpointParseException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param str Describes the failure and includes the string that could not be parsed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(str?: string, ice_cause?: string | Error);
        str: string;
    }

    /**
     * This exception is raised if there was an error while parsing an
     * endpoint selection type.
     */
    class EndpointSelectionTypeParseException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param str Describes the failure and includes the string that could not be parsed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(str?: string, ice_cause?: string | Error);
        str: string;
    }

    /**
     * This exception is raised if there was an error while parsing a
     * version.
     */
    class VersionParseException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param str Describes the failure and includes the string that could not be parsed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(str?: string, ice_cause?: string | Error);
        str: string;
    }

    /**
     * This exception is raised if there was an error while parsing a
     * stringified identity.
     */
    class IdentityParseException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param str Describes the failure and includes the string that could not be parsed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(str?: string, ice_cause?: string | Error);
        str: string;
    }

    /**
     * This exception is raised if there was an error while parsing a
     * stringified proxy.
     */
    class ProxyParseException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param str Describes the failure and includes the string that could not be parsed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(str?: string, ice_cause?: string | Error);
        str: string;
    }

    /**
     * This exception is raised if an illegal identity is encountered.
     */
    class IllegalIdentityException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The illegal identity.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Identity, ice_cause?: string | Error);
        id: Identity;
    }

    /**
     * This exception is raised to reject an illegal servant (typically
     * a null servant)
     */
    class IllegalServantException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason Describes why this servant is illegal.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception is raised if a request failed. This exception, and
     * all exceptions derived from {@link RequestFailedException}, are
     * transmitted by the Ice protocol, even though they are declared
     * <code>local</code>.
     */
    class RequestFailedException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the Ice Object to which the request was sent.
         * @param facet The facet to which the request was sent.
         * @param operation The operation name of the request.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Identity, facet?: string, operation?: string, ice_cause?: string | Error);
        id: Identity;
        facet: string;
        operation: string;
    }

    /**
     * This exception is raised if an object does not exist on the server,
     * that is, if no facets with the given identity exist.
     */
    class ObjectNotExistException extends RequestFailedException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the Ice Object to which the request was sent.
         * @param facet The facet to which the request was sent.
         * @param operation The operation name of the request.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Identity, facet?: string, operation?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if no facet with the given name exists,
     * but at least one facet with the given identity exists.
     */
    class FacetNotExistException extends RequestFailedException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the Ice Object to which the request was sent.
         * @param facet The facet to which the request was sent.
         * @param operation The operation name of the request.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Identity, facet?: string, operation?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if an operation for a given object does
     * not exist on the server. Typically this is caused by either the
     * client or the server using an outdated Slice specification.
     */
    class OperationNotExistException extends RequestFailedException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the Ice Object to which the request was sent.
         * @param facet The facet to which the request was sent.
         * @param operation The operation name of the request.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Identity, facet?: string, operation?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if a system error occurred in the server
     * or client process. There are many possible causes for such a system
     * exception. For details on the cause, {@link SyscallException#error}
     * should be inspected.
     */
    class SyscallException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, ice_cause?: string | Error);
        error: number;
    }

    /**
     * This exception indicates socket errors.
     */
    class SocketException extends SyscallException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, ice_cause?: string | Error);
    }

    /**
     * This exception indicates CFNetwork errors.
     */
    class CFNetworkException extends SocketException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param domain The domain of the error.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, domain?: string, ice_cause?: string | Error);
        domain: string;
    }

    /**
     * This exception indicates file errors.
     */
    class FileException extends SyscallException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param path The path of the file responsible for the error.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, path?: string, ice_cause?: string | Error);
        path: string;
    }

    /**
     * This exception indicates connection failures.
     */
    class ConnectFailedException extends SocketException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, ice_cause?: string | Error);
    }

    /**
     * This exception indicates a connection failure for which
     * the server host actively refuses a connection.
     */
    class ConnectionRefusedException extends ConnectFailedException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, ice_cause?: string | Error);
    }

    /**
     * This exception indicates a lost connection.
     */
    class ConnectionLostException extends SocketException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the system exception.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, ice_cause?: string | Error);
    }

    /**
     * This exception indicates a DNS problem. For details on the cause,
     * {@link DNSException#error} should be inspected.
     */
    class DNSException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param error The error number describing the DNS problem.
         * @param host The host name that could not be resolved.
         * @param ice_cause The error that cause this exception.
         */
        constructor(error?: number, host?: string, ice_cause?: string | Error);
        error: number;
        host: string;
    }

    /**
     * This exception indicates a request was interrupted.
     */
    class OperationInterruptedException extends LocalException {
    }

    /**
     * This exception indicates a timeout condition.
     */
    class TimeoutException extends LocalException {
    }

    /**
     * This exception indicates a connection establishment timeout condition.
     */
    class ConnectTimeoutException extends TimeoutException {
    }

    /**
     * This exception indicates a connection closure timeout condition.
     */
    class CloseTimeoutException extends TimeoutException {
    }

    /**
     * This exception indicates that a connection has been shut down because it has been
     * idle for some time.
     */
    class ConnectionTimeoutException extends TimeoutException {
    }

    /**
     * This exception indicates that an invocation failed because it timed
     * out.
     */
    class InvocationTimeoutException extends TimeoutException {
    }

    /**
     * This exception indicates that an asynchronous invocation failed
     * because it was canceled explicitly by the user.
     */
    class InvocationCanceledException extends LocalException {
    }

    /**
     * A generic exception base for all kinds of protocol error
     * conditions.
     */
    class ProtocolException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception indicates that a message did not start with the expected
     * magic number ('I', 'c', 'e', 'P').
     */
    class BadMagicException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param badMagic A sequence containing the first four bytes of the incorrect message.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, badMagic?: ByteSeq, ice_cause?: string | Error);
        badMagic: ByteSeq;
    }

    /**
     * This exception indicates an unsupported protocol version.
     */
    class UnsupportedProtocolException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param bad The version of the unsupported protocol.
         * @param supported The version of the protocol that is supported.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, bad?: ProtocolVersion, supported?: ProtocolVersion, ice_cause?: string | Error);
        bad: ProtocolVersion;
        supported: ProtocolVersion;
    }

    /**
     * This exception indicates an unsupported data encoding version.
     */
    class UnsupportedEncodingException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param bad The version of the unsupported encoding.
         * @param supported The version of the encoding that is supported.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, bad?: EncodingVersion, supported?: EncodingVersion, ice_cause?: string | Error);
        bad: EncodingVersion;
        supported: EncodingVersion;
    }

    /**
     * This exception indicates that an unknown protocol message has been received.
     */
    class UnknownMessageException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if a message is received over a connection
     * that is not yet validated.
     */
    class ConnectionNotValidatedException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception indicates that a response for an unknown request ID has been
     * received.
     */
    class UnknownRequestIdException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception indicates that an unknown reply status has been received.
     */
    class UnknownReplyStatusException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception indicates that the connection has been gracefully shut down by the
     * server. The operation call that caused this exception has not been
     * executed by the server. In most cases you will not get this
     * exception, because the client will automatically retry the
     * operation call in case the server shut down the connection. However,
     * if upon retry the server shuts down the connection again, and the
     * retry limit has been reached, then this exception is propagated to
     * the application code.
     */
    class CloseConnectionException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised by an operation call if the application
     * closes the connection locally using {@link Connection#close}.
     * @see Connection#close
     */
    class ConnectionManuallyClosedException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param graceful True if the connection was closed gracefully, false otherwise.
         * @param ice_cause The error that cause this exception.
         */
        constructor(graceful?: boolean, ice_cause?: string | Error);
        graceful: boolean;
    }

    /**
     * This exception indicates that a message size is less
     * than the minimum required size.
     */
    class IllegalMessageSizeException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception indicates a problem with compressing or uncompressing data.
     */
    class CompressionException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * A datagram exceeds the configured size.
     *
     * This exception is raised if a datagram exceeds the configured send or receive buffer
     * size, or exceeds the maximum payload size of a UDP packet (65507 bytes).
     */
    class DatagramLimitException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised for errors during marshaling or unmarshaling data.
     */
    class MarshalException extends ProtocolException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if inconsistent data is received while unmarshaling a proxy.
     */
    class ProxyUnmarshalException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if an out-of-bounds condition occurs during unmarshaling.
     */
    class UnmarshalOutOfBoundsException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if no suitable value factory was found during
     * unmarshaling of a Slice class instance.
     * @see ValueFactory
     * @see Communicator#getValueFactoryManager
     * @see ValueFactoryManager#add
     * @see ValueFactoryManager#find
     */
    class NoValueFactoryException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param type The Slice type ID of the class instance for which no no factory could be found.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, type?: string, ice_cause?: string | Error);
        type: string;
    }

    /**
     * This exception is raised if the type of an unmarshaled Slice class instance does
     * not match its expected type.
     * This can happen if client and server are compiled with mismatched Slice
     * definitions or if a class of the wrong type is passed as a parameter
     * or return value using dynamic invocation. This exception can also be
     * raised if IceStorm is used to send Slice class instances and
     * an operation is subscribed to the wrong topic.
     */
    class UnexpectedObjectException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param type The Slice type ID of the class instance that was unmarshaled.
         * @param expectedType The Slice type ID that was expected by the receiving operation.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, type?: string, expectedType?: string, ice_cause?: string | Error);
        type: string;
        expectedType: string;
    }

    /**
     * This exception is raised when Ice receives a request or reply
     * message whose size exceeds the limit specified by the
     * <code>Ice.MessageSizeMax</code> property.
     */
    class MemoryLimitException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised when a string conversion to or from UTF-8
     * fails during marshaling or unmarshaling.
     */
    class StringConversionException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception indicates a malformed data encapsulation.
     */
    class EncapsulationException extends MarshalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if an unsupported feature is used. The
     * unsupported feature string contains the name of the unsupported
     * feature
     */
    class FeatureNotSupportedException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param unsupportedFeature The name of the unsupported feature.
         * @param ice_cause The error that cause this exception.
         */
        constructor(unsupportedFeature?: string, ice_cause?: string | Error);
        unsupportedFeature: string;
    }

    /**
     * This exception indicates a failure in a security subsystem,
     * such as the IceSSL plug-in.
     */
    class SecurityException extends LocalException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception indicates that an attempt has been made to
     * change the connection properties of a fixed proxy.
     */
    class FixedProxyException extends LocalException {
    }

    /**
     * Indicates that the response to a request has already been sent;
     * re-dispatching such a request is not possible.
     */
    class ResponseSentException extends LocalException {
    }
}

export namespace Ice {
    /**
     * This exception is raised if an adapter cannot be found.
     */
    class AdapterNotFoundException extends UserException {
    }

    /**
     * This exception is raised if the replica group provided by the
     * server is invalid.
     */
    class InvalidReplicaGroupIdException extends UserException {
    }

    /**
     * This exception is raised if a server tries to set endpoints for
     * an adapter that is already active.
     */
    class AdapterAlreadyActiveException extends UserException {
    }

    /**
     * This exception is raised if an object cannot be found.
     */
    class ObjectNotFoundException extends UserException {
    }

    /**
     * This exception is raised if a server cannot be found.
     */
    class ServerNotFoundException extends UserException {
    }

    abstract class LocatorPrx extends ObjectPrx {
        /**
         * Find an object by identity and return a proxy that contains
         * the adapter ID or endpoints which can be used to access the
         * object.
         * @param id The identity.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findObjectById(id: Identity, context?: Map<string, string>): AsyncResult<Ice.ObjectPrx>;
        /**
         * Find an adapter by id and return a proxy that contains
         * its endpoints.
         * @param id The adapter id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findAdapterById(id: string, context?: Map<string, string>): AsyncResult<Ice.ObjectPrx>;
        /**
         * Get the locator registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegistry(context?: Map<string, string>): AsyncResult<LocatorRegistryPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): LocatorPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<LocatorPrx>;
    }

    abstract class Locator extends Object {
        /**
         * The Ice locator interface. This interface is used by clients to
         * lookup adapters and objects. It is also used by servers to get the
         * locator registry proxy.
         *
         * <p class="Note">The {@link Locator} interface is intended to be used by
         * Ice internals and by locator implementations. Regular user code
         * should not attempt to use any functionality of this interface
         * directly.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findObjectById(id: Identity, current: Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The Ice locator interface. This interface is used by clients to
         * lookup adapters and objects. It is also used by servers to get the
         * locator registry proxy.
         *
         * <p class="Note">The {@link Locator} interface is intended to be used by
         * Ice internals and by locator implementations. Regular user code
         * should not attempt to use any functionality of this interface
         * directly.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findAdapterById(id: string, current: Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The Ice locator interface. This interface is used by clients to
         * lookup adapters and objects. It is also used by servers to get the
         * locator registry proxy.
         *
         * <p class="Note">The {@link Locator} interface is intended to be used by
         * Ice internals and by locator implementations. Regular user code
         * should not attempt to use any functionality of this interface
         * directly.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRegistry(current: Current): PromiseLike<LocatorRegistryPrx> | LocatorRegistryPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::Locator".
         */
        static ice_staticId(): string;
    }

    abstract class LocatorRegistryPrx extends ObjectPrx {
        /**
         * Set the adapter endpoints with the locator registry.
         * @param id The adapter id.
         * @param proxy The adapter proxy (a dummy direct proxy created
         * by the adapter). The direct proxy contains the adapter
         * endpoints.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setAdapterDirectProxy(id: string, proxy: Ice.ObjectPrx, context?: Map<string, string>): AsyncResult<void>;
        /**
         * Set the adapter endpoints with the locator registry.
         * @param adapterId The adapter id.
         * @param replicaGroupId The replica group id.
         * @param p The adapter proxy (a dummy direct proxy created
         * by the adapter). The direct proxy contains the adapter
         * endpoints.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setReplicatedAdapterDirectProxy(adapterId: string, replicaGroupId: string, p: Ice.ObjectPrx, context?: Map<string, string>): AsyncResult<void>;
        /**
         * Set the process proxy for a server.
         * @param id The server id.
         * @param proxy The process proxy.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setServerProcessProxy(id: string, proxy: ProcessPrx, context?: Map<string, string>): AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): LocatorRegistryPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<LocatorRegistryPrx>;
    }

    abstract class LocatorRegistry extends Object {
        /**
         * The Ice locator registry interface. This interface is used by
         * servers to register adapter endpoints with the locator.
         *
         * <p class="Note"> The {@link LocatorRegistry} interface is intended to be used
         * by Ice internals and by locator implementations. Regular user
         * code should not attempt to use any functionality of this interface
         * directly.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setAdapterDirectProxy(id: string, proxy: Ice.ObjectPrx, current: Current): PromiseLike<void> | void;
        /**
         * The Ice locator registry interface. This interface is used by
         * servers to register adapter endpoints with the locator.
         *
         * <p class="Note"> The {@link LocatorRegistry} interface is intended to be used
         * by Ice internals and by locator implementations. Regular user
         * code should not attempt to use any functionality of this interface
         * directly.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setReplicatedAdapterDirectProxy(adapterId: string, replicaGroupId: string, p: Ice.ObjectPrx, current: Current): PromiseLike<void> | void;
        /**
         * The Ice locator registry interface. This interface is used by
         * servers to register adapter endpoints with the locator.
         *
         * <p class="Note"> The {@link LocatorRegistry} interface is intended to be used
         * by Ice internals and by locator implementations. Regular user
         * code should not attempt to use any functionality of this interface
         * directly.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setServerProcessProxy(id: string, proxy: ProcessPrx, current: Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::LocatorRegistry".
         */
        static ice_staticId(): string;
    }

    abstract class LocatorFinderPrx extends ObjectPrx {
        /**
         * Get the locator proxy implemented by the process hosting this
         * finder object. The proxy might point to several replicas.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLocator(context?: Map<string, string>): AsyncResult<LocatorPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): LocatorFinderPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<LocatorFinderPrx>;
    }

    abstract class LocatorFinder extends Object {
        /**
         * This inferface should be implemented by services implementing the
         * Ice::Locator interface. It should be advertised through an Ice
         * object with the identity `Ice/LocatorFinder'. This allows clients
         * to retrieve the locator proxy with just the endpoint information of
         * the service.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getLocator(current: Current): PromiseLike<LocatorPrx> | LocatorPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::LocatorFinder".
         */
        static ice_staticId(): string;
    }
}

export namespace Ice {
}

export namespace Ice {
    /**
     * The Ice message logger. Applications can provide their own logger
     * by implementing this interface and installing it in a communicator.
     */
    interface Logger {
        /**
         * Print a message. The message is printed literally, without
         * any decorations such as executable name or time stamp.
         * @param message The message to log.
         */
        print(message: string): void;
        /**
         * Log a trace message.
         * @param category The trace category.
         * @param message The trace message to log.
         */
        trace(category: string, message: string): void;
        /**
         * Log a warning message.
         * @param message The warning message to log.
         * @see #error
         */
        warning(message: string): void;
        /**
         * Log an error message.
         * @param message The error message to log.
         * @see #warning
         */
        error(message: string): void;
        /**
         * Returns this logger's prefix.
         * @return The prefix.
         */
        getPrefix(): string;
        /**
         * Returns a clone of the logger with a new prefix.
         * @param prefix The new prefix for the logger.
         * @return A logger instance.
         */
        cloneWithPrefix(prefix: string): Ice.Logger;
    }
}

export namespace Ice {
}

export namespace IceMX {
    /**
     * A dictionnary of strings to integers.
     */
    class StringIntDict extends Map<string, number>
    {
    }

    class StringIntDictHelper {
        static write(outs: Ice.OutputStream, value: StringIntDict): void;
        static read(ins: Ice.InputStream): StringIntDict;
    }

    /**
     * The base class for metrics. A metrics object represents a
     * collection of measurements associated to a given a system.
     */
    class Metrics extends Ice.Value {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number);
        /**
         * The metrics identifier.
         */
        id: string;
        /**
         * The total number of objects that were observed by this metrics.
         */
        total: Ice.Long;
        /**
         * The current number of objects observed by this metrics.
         */
        current: number;
        /**
         * The sum of the lifetime of each observed objects. This does not
         * include the lifetime of objects which are currently observed.
         */
        totalLifetime: Ice.Long;
        /**
         * The number of failures observed.
         */
        failures: number;
    }

    /**
     * A structure to keep track of failures associated with a given
     * metrics.
     */
    class MetricsFailures {
        constructor(id?: string, failures?: StringIntDict);
        clone(): MetricsFailures;
        equals(rhs: any): boolean;
        id: string;
        failures: StringIntDict;
        static write(outs: Ice.OutputStream, value: MetricsFailures): void;
        static read(ins: Ice.InputStream): MetricsFailures;
    }

    /**
     * A sequence of {@link MetricsFailures}.
     */
    type MetricsFailuresSeq = MetricsFailures[];

    class MetricsFailuresSeqHelper {
        static write(outs: Ice.OutputStream, value: MetricsFailuresSeq): void;
        static read(ins: Ice.InputStream): MetricsFailuresSeq;
    }

    /**
     * A metrics map is a sequence of metrics. We use a sequence here
     * instead of a map because the ID of the metrics is already included
     * in the Metrics class and using sequences of metrics objects is more
     * efficient than using dictionaries since lookup is not necessary.
     */
    type MetricsMap = IceMX.Metrics[];

    class MetricsMapHelper {
        static write(outs: Ice.OutputStream, value: MetricsMap): void;
        static read(ins: Ice.InputStream): MetricsMap;
    }

    /**
     * A metrics view is a dictionary of metrics map. The key of the
     * dictionary is the name of the metrics map.
     */
    class MetricsView extends Map<string, MetricsMap>
    {
    }

    class MetricsViewHelper {
        static write(outs: Ice.OutputStream, value: MetricsView): void;
        static read(ins: Ice.InputStream): MetricsView;
    }

    /**
     * Raised if a metrics view cannot be found.
     */
    class UnknownMetricsView extends Ice.UserException {
    }

    abstract class MetricsAdminPrx extends Ice.ObjectPrx {
        /**
         * Get the names of enabled and disabled metrics.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getMetricsViewNames(context?: Map<string, string>): Ice.AsyncResult<[Ice.StringSeq, Ice.StringSeq]>;
        /**
         * Enables a metrics view.
         * @param name The metrics view name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        enableMetricsView(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Disable a metrics view.
         * @param name The metrics view name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        disableMetricsView(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get the metrics objects for the given metrics view. This
         * returns a dictionnary of metric maps for each metrics class
         * configured with the view. The timestamp allows the client to
         * compute averages which are not dependent of the invocation
         * latency for this operation.
         * @param view The name of the metrics view.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getMetricsView(view: string, context?: Map<string, string>): Ice.AsyncResult<[MetricsView, Ice.Long]>;
        /**
         * Get the metrics failures associated with the given view and map.
         * @param view The name of the metrics view.
         * @param map The name of the metrics map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getMapMetricsFailures(view: string, map: string, context?: Map<string, string>): Ice.AsyncResult<MetricsFailuresSeq>;
        /**
         * Get the metrics failure associated for the given metrics.
         * @param view The name of the metrics view.
         * @param map The name of the metrics map.
         * @param id The ID of the metrics.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getMetricsFailures(view: string, map: string, id: string, context?: Map<string, string>): Ice.AsyncResult<MetricsFailures>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): MetricsAdminPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<MetricsAdminPrx>;
    }

    abstract class MetricsAdmin extends Ice.Object {
        /**
         * The metrics administrative facet interface. This interface allows
         * remote administrative clients to access metrics of an application
         * that enabled the Ice administrative facility and configured some
         * metrics views.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getMetricsViewNames(current: Ice.Current): PromiseLike<[Ice.StringSeq, Ice.StringSeq]> | [Ice.StringSeq, Ice.StringSeq];
        /**
         * The metrics administrative facet interface. This interface allows
         * remote administrative clients to access metrics of an application
         * that enabled the Ice administrative facility and configured some
         * metrics views.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract enableMetricsView(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The metrics administrative facet interface. This interface allows
         * remote administrative clients to access metrics of an application
         * that enabled the Ice administrative facility and configured some
         * metrics views.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract disableMetricsView(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The metrics administrative facet interface. This interface allows
         * remote administrative clients to access metrics of an application
         * that enabled the Ice administrative facility and configured some
         * metrics views.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getMetricsView(view: string, current: Ice.Current): PromiseLike<[MetricsView, Ice.Long]> | [MetricsView, Ice.Long];
        /**
         * The metrics administrative facet interface. This interface allows
         * remote administrative clients to access metrics of an application
         * that enabled the Ice administrative facility and configured some
         * metrics views.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getMapMetricsFailures(view: string, map: string, current: Ice.Current): PromiseLike<MetricsFailuresSeq> | MetricsFailuresSeq;
        /**
         * The metrics administrative facet interface. This interface allows
         * remote administrative clients to access metrics of an application
         * that enabled the Ice administrative facility and configured some
         * metrics views.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getMetricsFailures(view: string, map: string, id: string, current: Ice.Current): PromiseLike<MetricsFailures> | MetricsFailures;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceMX::MetricsAdmin".
         */
        static ice_staticId(): string;
    }

    /**
     * Provides information on the number of threads currently in use and
     * their activity.
     */
    class ThreadMetrics extends Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param inUseForIO The number of threads which are currently performing socket read or writes.
         * @param inUseForUser The number of threads which are currently calling user code (servant dispatch, AMI callbacks, etc).
         * @param inUseForOther The number of threads which are currently performing other activities.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, inUseForIO?: number, inUseForUser?: number, inUseForOther?: number);
        /**
         * The number of threads which are currently performing socket
         * read or writes.
         */
        inUseForIO: number;
        /**
         * The number of threads which are currently calling user code
         * (servant dispatch, AMI callbacks, etc).
         */
        inUseForUser: number;
        /**
         * The number of threads which are currently performing other
         * activities. These are all other that are not counted with
         * {@link #inUseForUser} or {@link #inUseForIO}, such as DNS
         * lookups, garbage collection).
         */
        inUseForOther: number;
    }

    /**
     * Provides information on servant dispatch.
     */
    class DispatchMetrics extends Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param userException The number of dispatch that failed with a user exception.
         * @param size The size of the dispatch.
         * @param replySize The size of the dispatch reply.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, userException?: number, size?: Ice.Long, replySize?: Ice.Long);
        /**
         * The number of dispatch that failed with a user exception.
         */
        userException: number;
        /**
         * The size of the dispatch. This corresponds to the size of the
         * marshalled input parameters.
         */
        size: Ice.Long;
        /**
         * The size of the dispatch reply. This corresponds to the size of
         * the marshalled output and return parameters.
         */
        replySize: Ice.Long;
    }

    /**
     * Provides information on child invocations. A child invocation is
     * either remote (sent over an Ice connection) or collocated. An
     * invocation can have multiple child invocation if it is
     * retried. Child invocation metrics are embedded within {@link
     * InvocationMetrics}.
     */
    class ChildInvocationMetrics extends Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param size The size of the invocation.
         * @param replySize The size of the invocation reply.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, size?: Ice.Long, replySize?: Ice.Long);
        /**
         * The size of the invocation. This corresponds to the size of the
         * marshalled input parameters.
         */
        size: Ice.Long;
        /**
         * The size of the invocation reply. This corresponds to the size
         * of the marshalled output and return parameters.
         */
        replySize: Ice.Long;
    }

    /**
     * Provides information on invocations that are collocated. Collocated
     * metrics are embedded within {@link InvocationMetrics}.
     */
    class CollocatedMetrics extends ChildInvocationMetrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param size The size of the invocation.
         * @param replySize The size of the invocation reply.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, size?: Ice.Long, replySize?: Ice.Long);
    }

    /**
     * Provides information on invocations that are specifically sent over
     * Ice connections. Remote metrics are embedded within {@link InvocationMetrics}.
     */
    class RemoteMetrics extends ChildInvocationMetrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param size The size of the invocation.
         * @param replySize The size of the invocation reply.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, size?: Ice.Long, replySize?: Ice.Long);
    }

    /**
     * Provide measurements for proxy invocations. Proxy invocations can
     * either be sent over the wire or be collocated.
     */
    class InvocationMetrics extends Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param retry The number of retries for the invocation(s).
         * @param userException The number of invocations that failed with a user exception.
         * @param remotes The remote invocation metrics map.
         * @param collocated The collocated invocation metrics map.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, retry?: number, userException?: number, remotes?: MetricsMap, collocated?: MetricsMap);
        /**
         * The number of retries for the invocation(s).
         */
        retry: number;
        /**
         * The number of invocations that failed with a user exception.
         */
        userException: number;
        /**
         * The remote invocation metrics map.
         * @see RemoteMetrics
         */
        remotes: MetricsMap;
        /**
         * The collocated invocation metrics map.
         * @see CollocatedMetrics
         */
        collocated: MetricsMap;
    }

    /**
     * Provides information on the data sent and received over Ice
     * connections.
     */
    class ConnectionMetrics extends Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param receivedBytes The number of bytes received by the connection.
         * @param sentBytes The number of bytes sent by the connection.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, receivedBytes?: Ice.Long, sentBytes?: Ice.Long);
        /**
         * The number of bytes received by the connection.
         */
        receivedBytes: Ice.Long;
        /**
         * The number of bytes sent by the connection.
         */
        sentBytes: Ice.Long;
    }
}

export namespace Ice {
    /**
     * The object adapter provides an up-call interface from the Ice
     * run time to the implementation of Ice objects.
     *
     * The object adapter is responsible for receiving requests
     * from endpoints, and for mapping between servants, identities, and
     * proxies.
     * @see Communicator
     * @see ServantLocator
     */
    interface ObjectAdapter {
        /**
         * Get the name of this object adapter.
         * @return This object adapter's name.
         */
        getName(): string;
        /**
         * Get the communicator this object adapter belongs to.
         * @return This object adapter's communicator.
         * @see Communicator
         */
        getCommunicator(): Ice.Communicator;
        /**
         * Activate all endpoints that belong to this object adapter.
         * After activation, the object adapter can dispatch requests
         * received through its endpoints.
         * @return @returns The asynchronous result object for the invocation.
         * @see #hold
         * @see #deactivate
         */
        activate(): AsyncResultBase<void>;
        /**
         * Temporarily hold receiving and dispatching requests. The object
         * adapter can be reactivated with the {@link #activate} operation.
         *
         * <p class="Note"> Holding is not immediate, i.e., after {@link #hold}
         * returns, the object adapter might still be active for some
         * time. You can use {@link #waitForHold} to wait until holding is
         * complete.
         * @see #activate
         * @see #deactivate
         * @see #waitForHold
         */
        hold(): void;
        /**
         * Wait until the object adapter holds requests. Calling {@link #hold}
         * initiates holding of requests, and {@link #waitForHold} only returns
         * when holding of requests has been completed.
         * @return @returns The asynchronous result object for the invocation.
         * @see #hold
         * @see #waitForDeactivate
         * @see Communicator#waitForShutdown
         */
        waitForHold(): AsyncResultBase<void>;
        /**
         * Deactivate all endpoints that belong to this object adapter.
         * After deactivation, the object adapter stops receiving
         * requests through its endpoints. Object adapters that have been
         * deactivated must not be reactivated again, and cannot be used
         * otherwise. Attempts to use a deactivated object adapter raise
         * {@link ObjectAdapterDeactivatedException} however, attempts to
         * {@link #deactivate} an already deactivated object adapter are
         * ignored and do nothing. Once deactivated, it is possible to
         * destroy the adapter to clean up resources and then create and
         * activate a new adapter with the same name.
         *
         * <p class="Note"> After {@link #deactivate} returns, no new requests
         * are processed by the object adapter. However, requests that
         * have been started before {@link #deactivate} was called might
         * still be active. You can use {@link #waitForDeactivate} to wait
         * for the completion of all requests for this object adapter.
         * @return @returns The asynchronous result object for the invocation.
         * @see #activate
         * @see #hold
         * @see #waitForDeactivate
         * @see Communicator#shutdown
         */
        deactivate(): AsyncResultBase<void>;
        /**
         * Wait until the object adapter has deactivated. Calling
         * {@link #deactivate} initiates object adapter deactivation, and
         * {@link #waitForDeactivate} only returns when deactivation has
         * been completed.
         * @return @returns The asynchronous result object for the invocation.
         * @see #deactivate
         * @see #waitForHold
         * @see Communicator#waitForShutdown
         */
        waitForDeactivate(): AsyncResultBase<void>;
        /**
         * Check whether object adapter has been deactivated.
         * @return Whether adapter has been deactivated.
         * @see Communicator#shutdown
         */
        isDeactivated(): boolean;
        /**
         * Destroys the object adapter and cleans up all resources held by
         * the object adapter. If the object adapter has not yet been
         * deactivated, destroy implicitly initiates the deactivation
         * and waits for it to finish. Subsequent calls to destroy are
         * ignored. Once destroy has returned, it is possible to create
         * another object adapter with the same name.
         * @return @returns The asynchronous result object for the invocation.
         * @see #deactivate
         * @see #waitForDeactivate
         * @see Communicator#destroy
         */
        destroy(): AsyncResultBase<void>;
        /**
         * Add a servant to this object adapter's Active Servant Map. Note
         * that one servant can implement several Ice objects by registering
         * the servant with multiple identities. Adding a servant with an
         * identity that is in the map already throws {@link AlreadyRegisteredException}.
         * @param servant The servant to add.
         * @param id The identity of the Ice object that is implemented by
         * the servant.
         * @return A proxy that matches the given identity and this object
         * adapter.
         * @see Identity
         * @see #addFacet
         * @see #addWithUUID
         * @see #remove
         * @see #find
         */
        add(servant: Ice.Object, id: Identity): Ice.ObjectPrx;
        /**
         * Like {@link #add}, but with a facet. Calling <code>add(servant, id)</code>
         * is equivalent to calling {@link #addFacet} with an empty facet.
         * @param servant The servant to add.
         * @param id The identity of the Ice object that is implemented by
         * the servant.
         * @param facet The facet. An empty facet means the default facet.
         * @return A proxy that matches the given identity, facet, and
         * this object adapter.
         * @see Identity
         * @see #add
         * @see #addFacetWithUUID
         * @see #removeFacet
         * @see #findFacet
         */
        addFacet(servant: Ice.Object, id: Identity, facet: string): Ice.ObjectPrx;
        /**
         * Add a servant to this object adapter's Active Servant Map,
         * using an automatically generated UUID as its identity. Note that
         * the generated UUID identity can be accessed using the proxy's
         * <code>ice_getIdentity</code> operation.
         * @param servant The servant to add.
         * @return A proxy that matches the generated UUID identity and
         * this object adapter.
         * @see Identity
         * @see #add
         * @see #addFacetWithUUID
         * @see #remove
         * @see #find
         */
        addWithUUID(servant: Ice.Object): Ice.ObjectPrx;
        /**
         * Like {@link #addWithUUID}, but with a facet. Calling
         * <code>addWithUUID(servant)</code> is equivalent to calling
         * {@link #addFacetWithUUID} with an empty facet.
         * @param servant The servant to add.
         * @param facet The facet. An empty facet means the default
         * facet.
         * @return A proxy that matches the generated UUID identity,
         * facet, and this object adapter.
         * @see Identity
         * @see #addFacet
         * @see #addWithUUID
         * @see #removeFacet
         * @see #findFacet
         */
        addFacetWithUUID(servant: Ice.Object, facet: string): Ice.ObjectPrx;
        /**
         * Add a default servant to handle requests for a specific
         * category. Adding a default servant for a category for
         * which a default servant is already registered throws
         * {@link AlreadyRegisteredException}. To dispatch operation
         * calls on servants, the object adapter tries to find a servant
         * for a given Ice object identity and facet in the following
         * order:
         *
         * <ol>
         *
         * <li>The object adapter tries to find a servant for the identity
         * and facet in the Active Servant Map.</li>
         *
         * <li>If no servant has been found in the Active Servant Map, the
         * object adapter tries to find a default servant for the category
         * component of the identity.</li>
         *
         * <li>If no servant has been found by any of the preceding steps,
         * the object adapter tries to find a default servant for an empty
         * category, regardless of the category contained in the identity.</li>
         *
         * <li>If no servant has been found by any of the preceding steps,
         * the object adapter gives up and the caller receives
         * {@link ObjectNotExistException} or {@link FacetNotExistException}.</li>
         *
         * </ol>
         * @param servant The default servant.
         * @param category The category for which the default servant is
         * registered. An empty category means it will handle all categories.
         * @see #removeDefaultServant
         * @see #findDefaultServant
         */
        addDefaultServant(servant: Ice.Object, category: string): void;
        /**
         * Remove a servant (that is, the default facet) from the object
         * adapter's Active Servant Map.
         * @param id The identity of the Ice object that is implemented by
         * the servant. If the servant implements multiple Ice objects,
         * {@link #remove} has to be called for all those Ice objects.
         * Removing an identity that is not in the map throws
         * {@link NotRegisteredException}.
         * @return The removed servant.
         * @see Identity
         * @see #add
         * @see #addWithUUID
         */
        remove(id: Identity): Ice.Object;
        /**
         * Like {@link #remove}, but with a facet. Calling <code>remove(id)</code>
         * is equivalent to calling {@link #removeFacet} with an empty facet.
         * @param id The identity of the Ice object that is implemented by
         * the servant.
         * @param facet The facet. An empty facet means the default facet.
         * @return The removed servant.
         * @see Identity
         * @see #addFacet
         * @see #addFacetWithUUID
         */
        removeFacet(id: Identity, facet: string): Ice.Object;
        /**
         * Remove all facets with the given identity from the Active
         * Servant Map. The operation completely removes the Ice object,
         * including its default facet. Removing an identity that
         * is not in the map throws {@link NotRegisteredException}.
         * @param id The identity of the Ice object to be removed.
         * @return A collection containing all the facet names and
         * servants of the removed Ice object.
         * @see #remove
         * @see #removeFacet
         */
        removeAllFacets(id: Identity): FacetMap;
        /**
         * Remove the default servant for a specific category. Attempting
         * to remove a default servant for a category that is not
         * registered throws {@link NotRegisteredException}.
         * @param category The category of the default servant to remove.
         * @return The default servant.
         * @see #addDefaultServant
         * @see #findDefaultServant
         */
        removeDefaultServant(category: string): Ice.Object;
        /**
         * Look up a servant in this object adapter's Active Servant Map
         * by the identity of the Ice object it implements.
         *
         * <p class="Note">This operation only tries to look up a servant in
         * the Active Servant Map. It does not attempt to find a servant
         * by using any installed {@link ServantLocator}.
         * @param id The identity of the Ice object for which the servant
         * should be returned.
         * @return The servant that implements the Ice object with the
         * given identity, or null if no such servant has been found.
         * @see Identity
         * @see #findFacet
         * @see #findByProxy
         */
        find(id: Identity): Ice.Object;
        /**
         * Like {@link #find}, but with a facet. Calling <code>find(id)</code>
         * is equivalent to calling {@link #findFacet} with an empty
         * facet.
         * @param id The identity of the Ice object for which the
         * servant should be returned.
         * @param facet The facet. An empty facet means the default
         * facet.
         * @return The servant that implements the Ice object with the
         * given identity and facet, or null if no such servant has been
         * found.
         * @see Identity
         * @see #find
         * @see #findByProxy
         */
        findFacet(id: Identity, facet: string): Ice.Object;
        /**
         * Find all facets with the given identity in the Active Servant
         * Map.
         * @param id The identity of the Ice object for which the facets
         * should be returned.
         * @return A collection containing all the facet names and
         * servants that have been found, or an empty map if there is no
         * facet for the given identity.
         * @see #find
         * @see #findFacet
         */
        findAllFacets(id: Identity): FacetMap;
        /**
         * Look up a servant in this object adapter's Active Servant Map,
         * given a proxy.
         *
         * <p class="Note">This operation only tries to lookup a servant in
         * the Active Servant Map. It does not attempt to find a servant
         * by using any installed {@link ServantLocator}.
         * @param proxy The proxy for which the servant should be returned.
         * @return The servant that matches the proxy, or null if no such
         * servant has been found.
         * @see #find
         * @see #findFacet
         */
        findByProxy(proxy: Ice.ObjectPrx): Ice.Object;
        /**
         * Add a Servant Locator to this object adapter. Adding a servant
         * locator for a category for which a servant locator is already
         * registered throws {@link AlreadyRegisteredException}. To dispatch
         * operation calls on servants, the object adapter tries to find a
         * servant for a given Ice object identity and facet in the
         * following order:
         *
         * <ol>
         *
         * <li>The object adapter tries to find a servant for the identity
         * and facet in the Active Servant Map.</li>
         *
         * <li>If no servant has been found in the Active Servant Map,
         * the object adapter tries to find a servant locator for the
         * category component of the identity. If a locator is found, the
         * object adapter tries to find a servant using this locator.</li>
         *
         * <li>If no servant has been found by any of the preceding steps,
         * the object adapter tries to find a locator for an empty category,
         * regardless of the category contained in the identity. If a
         * locator is found, the object adapter tries to find a servant
         * using this locator.</li>
         *
         * <li>If no servant has been found by any of the preceding steps,
         * the object adapter gives up and the caller receives
         * {@link ObjectNotExistException} or {@link FacetNotExistException}.</li>
         *
         * </ol>
         *
         * <p class="Note">Only one locator for the empty category can be
         * installed.
         * @param locator The locator to add.
         * @param category The category for which the Servant Locator can
         * locate servants, or an empty string if the Servant Locator does
         * not belong to any specific category.
         * @see Identity
         * @see #removeServantLocator
         * @see #findServantLocator
         * @see ServantLocator
         */
        addServantLocator(locator: Ice.ServantLocator, category: string): void;
        /**
         * Remove a Servant Locator from this object adapter.
         * @param category The category for which the Servant Locator can
         * locate servants, or an empty string if the Servant Locator does
         * not belong to any specific category.
         * @return The Servant Locator, or throws {@link NotRegisteredException}
         * if no Servant Locator was found for the given category.
         * @see Identity
         * @see #addServantLocator
         * @see #findServantLocator
         * @see ServantLocator
         */
        removeServantLocator(category: string): Ice.ServantLocator;
        /**
         * Find a Servant Locator installed with this object adapter.
         * @param category The category for which the Servant Locator can
         * locate servants, or an empty string if the Servant Locator does
         * not belong to any specific category.
         * @return The Servant Locator, or null if no Servant Locator was
         * found for the given category.
         * @see Identity
         * @see #addServantLocator
         * @see #removeServantLocator
         * @see ServantLocator
         */
        findServantLocator(category: string): Ice.ServantLocator;
        /**
         * Find the default servant for a specific category.
         * @param category The category of the default servant to find.
         * @return The default servant or null if no default servant was
         * registered for the category.
         * @see #addDefaultServant
         * @see #removeDefaultServant
         */
        findDefaultServant(category: string): Ice.Object;
        /**
         * Create a proxy for the object with the given identity. If this
         * object adapter is configured with an adapter id, the return
         * value is an indirect proxy that refers to the adapter id. If
         * a replica group id is also defined, the return value is an
         * indirect proxy that refers to the replica group id. Otherwise,
         * if no adapter id is defined, the return value is a direct
         * proxy containing this object adapter's published endpoints.
         * @param id The object's identity.
         * @return A proxy for the object with the given identity.
         * @see Identity
         */
        createProxy(id: Identity): Ice.ObjectPrx;
        /**
         * Create a direct proxy for the object with the given identity.
         * The returned proxy contains this object adapter's published
         * endpoints.
         * @param id The object's identity.
         * @return A proxy for the object with the given identity.
         * @see Identity
         */
        createDirectProxy(id: Identity): Ice.ObjectPrx;
        /**
         * Create an indirect proxy for the object with the given identity.
         * If this object adapter is configured with an adapter id, the
         * return value refers to the adapter id. Otherwise, the return
         * value contains only the object identity.
         * @param id The object's identity.
         * @return A proxy for the object with the given identity.
         * @see Identity
         */
        createIndirectProxy(id: Identity): Ice.ObjectPrx;
        /**
         * Set an Ice locator for this object adapter. By doing so, the
         * object adapter will register itself with the locator registry
         * when it is activated for the first time. Furthermore, the proxies
         * created by this object adapter will contain the adapter identifier
         * instead of its endpoints. The adapter identifier must be configured
         * using the AdapterId property.
         * @param loc The locator used by this object adapter.
         * @see #createDirectProxy
         * @see Locator
         * @see LocatorRegistry
         */
        setLocator(loc: LocatorPrx): void;
        /**
         * Get the Ice locator used by this object adapter.
         * @return The locator used by this object adapter, or null if no locator is
         * used by this object adapter.
         * @see Locator
         * @see #setLocator
         */
        getLocator(): LocatorPrx;
        /**
         * Get the set of endpoints configured with this object adapter.
         * @return The set of endpoints.
         * @see Endpoint
         */
        getEndpoints(): EndpointSeq;
        /**
         * Refresh the set of published endpoints. The run time re-reads
         * the PublishedEndpoints property if it is set and re-reads the
         * list of local interfaces if the adapter is configured to listen
         * on all endpoints. This operation is useful to refresh the endpoint
         * information that is published in the proxies that are created by
         * an object adapter if the network interfaces used by a host changes.
         * @return @returns The asynchronous result object for the invocation.
         */
        refreshPublishedEndpoints(): AsyncResultBase<void>;
        /**
         * Get the set of endpoints that proxies created by this object
         * adapter will contain.
         * @return The set of published endpoints.
         * @see #refreshPublishedEndpoints
         * @see Endpoint
         */
        getPublishedEndpoints(): EndpointSeq;
        /**
         * Set of the endpoints that proxies created by this object
         * adapter will contain.
         * @param newEndpoints The new set of endpoints that the object adapter will embed in proxies.
         * @see #refreshPublishedEndpoints
         * @see Endpoint
         */
        setPublishedEndpoints(newEndpoints: EndpointSeq): void;
    }
}

export namespace Ice {
}

export namespace Ice {
    /**
     * A factory for objects. Object factories are used when receiving "objects by value".
     * An object factory must be implemented by the application writer and registered
     * with the communicator.
     *
     * @deprecated ObjectFactory has been deprecated, use ValueFactory instead.
     */
    interface ObjectFactory {
        /**
         * Create a new object for a given object type. The type is the
         * absolute Slice type id, i.e., the id relative to the
         * unnamed top-level Slice module. For example, the absolute
         * Slice type id for interfaces of type <code>Bar</code> in the module
         * <code>Foo</code> is <code>"::Foo::Bar"</code>.
         *
         * <p class="Note">The leading "<code>::</code>" is required.
         * @param type The object type.
         * @return The object created for the given type, or nil if the
         * factory is unable to create the object.
         */
        create(type: string): Ice.Value;
        /**
         * Called when the factory is removed from the communicator, or if
         * the communicator is destroyed.
         * @see Communicator#destroy
         */
        destroy(): void;
    }
}

export namespace Ice {
}

export namespace Ice {
    abstract class ProcessPrx extends ObjectPrx {
        /**
         * Initiate a graceful shut-down.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see Communicator#shutdown
         */
        shutdown(context?: Map<string, string>): AsyncResult<void>;
        /**
         * Write a message on the process' stdout or stderr.
         * @param message The message.
         * @param fd 1 for stdout, 2 for stderr.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        writeMessage(message: string, fd: number, context?: Map<string, string>): AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): ProcessPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<ProcessPrx>;
    }

    abstract class Process extends Object {
        /**
         * An administrative interface for process management. Managed servers must
         * implement this interface.
         *
         * <p class="Note">A servant implementing this interface is a potential target
         * for denial-of-service attacks, therefore proper security precautions
         * should be taken. For example, the servant can use a UUID to make its
         * identity harder to guess, and be registered in an object adapter with
         * a secured endpoint.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract shutdown(current: Current): PromiseLike<void> | void;
        /**
         * An administrative interface for process management. Managed servers must
         * implement this interface.
         *
         * <p class="Note">A servant implementing this interface is a potential target
         * for denial-of-service attacks, therefore proper security precautions
         * should be taken. For example, the servant can use a UUID to make its
         * identity harder to guess, and be registered in an object adapter with
         * a secured endpoint.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract writeMessage(message: string, fd: number, current: Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::Process".
         */
        static ice_staticId(): string;
    }
}

export namespace Ice {
}

export class P<T> extends Promise<T>
{
    constructor(executor?: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason: any) => void) => void);
    finally(callback: () => void | PromiseLike<void>): T | PromiseLike<T>;
    delay(ms: number): P<T>;
    resolve<T>(value?: T | PromiseLike<T>): void;
    reject<T>(reason: any): void;
    static delay(ms: number): P<void>;
    static delay<T>(ms: number, value: T): P<T>;
    static try<T>(cb: () => T | PromiseLike<T>): P<T>;
}

export namespace Ice {
    /**
     * A property set used to configure Ice and Ice applications.
     * Properties are key/value pairs, with both keys and values
     * being strings. By convention, property keys should have the form
     * <em>application-name</em>\[.<em>category</em>\[.<em>sub-category</em>]].<em>name</em>.
     */
    interface Properties {
        /**
         * Get a property by key. If the property is not set, an empty
         * string is returned.
         * @param key The property key.
         * @return The property value.
         * @see #setProperty
         */
        getProperty(key: string): string;
        /**
         * Get a property by key. If the property is not set, the
         * given default value is returned.
         * @param key The property key.
         * @param value The default value to use if the property does not
         * exist.
         * @return The property value or the default value.
         * @see #setProperty
         */
        getPropertyWithDefault(key: string, value: string): string;
        /**
         * Get a property as an integer. If the property is not set, 0
         * is returned.
         * @param key The property key.
         * @return The property value interpreted as an integer.
         * @see #setProperty
         */
        getPropertyAsInt(key: string): number;
        /**
         * Get a property as an integer. If the property is not set, the
         * given default value is returned.
         * @param key The property key.
         * @param value The default value to use if the property does not
         * exist.
         * @return The property value interpreted as an integer, or the
         * default value.
         * @see #setProperty
         */
        getPropertyAsIntWithDefault(key: string, value: number): number;
        /**
         * Get a property as a list of strings. The strings must be
         * separated by whitespace or comma. If the property is not set,
         * an empty list is returned. The strings in the list can contain
         * whitespace and commas if they are enclosed in single or double
         * quotes. If quotes are mismatched, an empty list is returned.
         * Within single quotes or double quotes, you can escape the
         * quote in question with \, e.g. O'Reilly can be written as
         * O'Reilly, "O'Reilly" or 'O\'Reilly'.
         * @param key The property key.
         * @return The property value interpreted as a list of strings.
         * @see #setProperty
         */
        getPropertyAsList(key: string): StringSeq;
        /**
         * Get a property as a list of strings.  The strings must be
         * separated by whitespace or comma. If the property is not set,
         * the default list is returned. The strings in the list can contain
         * whitespace and commas if they are enclosed in single or double
         * quotes. If quotes are mismatched, the default list is returned.
         * Within single quotes or double quotes, you can escape the
         * quote in question with \, e.g. O'Reilly can be written as
         * O'Reilly, "O'Reilly" or 'O\'Reilly'.
         * @param key The property key.
         * @param value The default value to use if the property is not set.
         * @return The property value interpreted as list of strings, or the
         * default value.
         * @see #setProperty
         */
        getPropertyAsListWithDefault(key: string, value: StringSeq): StringSeq;
        /**
         * Get all properties whose keys begins with
         * <em>prefix</em>. If
         * <em>prefix</em> is an empty string,
         * then all properties are returned.
         * @param prefix The prefix to search for (empty string if none).
         * @return The matching property set.
         */
        getPropertiesForPrefix(prefix: string): PropertyDict;
        /**
         * Set a property. To unset a property, set it to
         * the empty string.
         * @param key The property key.
         * @param value The property value.
         * @see #getProperty
         */
        setProperty(key: string, value: string): void;
        /**
         * Get a sequence of command-line options that is equivalent to
         * this property set. Each element of the returned sequence is
         * a command-line option of the form
         * <code>--<em>key</em>=<em>value</em></code>.
         * @return The command line options for this property set.
         */
        getCommandLineOptions(): StringSeq;
        /**
         * Convert a sequence of command-line options into properties.
         * All options that begin with
         * <code>--<em>prefix</em>.</code> are
         * converted into properties. If the prefix is empty, all options
         * that begin with <code>--</code> are converted to properties.
         * @param prefix The property prefix, or an empty string to
         * convert all options starting with <code>--</code>.
         * @param options The command-line options.
         * @return The command-line options that do not start with the specified
         * prefix, in their original order.
         */
        parseCommandLineOptions(prefix: string, options: StringSeq): StringSeq;
        /**
         * Convert a sequence of command-line options into properties.
         * All options that begin with one of the following prefixes
         * are converted into properties: <code>--Ice</code>, <code>--IceBox</code>, <code>--IceGrid</code>,
         * <code>--IcePatch2</code>, <code>--IceSSL</code>, <code>--IceStorm</code>, <code>--Freeze</code>, and <code>--Glacier2</code>.
         * @param options The command-line options.
         * @return The command-line options that do not start with one of
         * the listed prefixes, in their original order.
         */
        parseIceCommandLineOptions(options: StringSeq): StringSeq;
        /**
         * Create a copy of this property set.
         * @return A copy of this property set.
         */
        clone(): Ice.Properties;
    }
}

export namespace Ice {
    /**
     * A simple collection of properties, represented as a dictionary of
     * key/value pairs. Both key and value are strings.
     * @see Properties#getPropertiesForPrefix
     */
    class PropertyDict extends Map<string, string>
    {
    }

    class PropertyDictHelper {
        static write(outs: OutputStream, value: PropertyDict): void;
        static read(ins: InputStream): PropertyDict;
    }

    abstract class PropertiesAdminPrx extends ObjectPrx {
        /**
         * Get a property by key. If the property is not set, an empty
         * string is returned.
         * @param key The property key.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getProperty(key: string, context?: Map<string, string>): AsyncResult<string>;
        /**
         * Get all properties whose keys begin with <em>prefix</em>. If
         * <em>prefix</em> is an empty string then all properties are returned.
         * @param prefix The prefix to search for (empty string if none).
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getPropertiesForPrefix(prefix: string, context?: Map<string, string>): AsyncResult<PropertyDict>;
        /**
         * Update the communicator's properties with the given property set.
         * @param newProperties Properties to be added, changed, or removed.
         * If an entry in <em>newProperties</em> matches the name of an existing property,
         * that property's value is replaced with the new value. If the new value
         * is an empty string, the property is removed. Any existing properties
         * that are not modified or removed by the entries in newProperties are
         * retained with their original values.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setProperties(newProperties: PropertyDict, context?: Map<string, string>): AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): PropertiesAdminPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<PropertiesAdminPrx>;
    }

    abstract class PropertiesAdmin extends Object {
        /**
         * The PropertiesAdmin interface provides remote access to the properties
         * of a communicator.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getProperty(key: string, current: Current): PromiseLike<string> | string;
        /**
         * The PropertiesAdmin interface provides remote access to the properties
         * of a communicator.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getPropertiesForPrefix(prefix: string, current: Current): PromiseLike<PropertyDict> | PropertyDict;
        /**
         * The PropertiesAdmin interface provides remote access to the properties
         * of a communicator.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setProperties(newProperties: PropertyDict, current: Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::PropertiesAdmin".
         */
        static ice_staticId(): string;
    }
}

export namespace Ice {
}

export namespace Ice {
    /**
     * An enumeration representing the different types of log messages.
     */
    class LogMessageType {
        /**
         * The {@link Logger} received a print message.
         */
        static readonly PrintMessage: LogMessageType;
        /**
         * The {@link Logger} received a trace message.
         */
        static readonly TraceMessage: LogMessageType;
        /**
         * The {@link Logger} received a warning message.
         */
        static readonly WarningMessage: LogMessageType;
        /**
         * The {@link Logger} received an error message.
         */
        static readonly ErrorMessage: LogMessageType;

        static valueOf(value: number): LogMessageType;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * A sequence of {@link LogMessageType}
     */
    type LogMessageTypeSeq = LogMessageType[];

    class LogMessageTypeSeqHelper {
        static write(outs: OutputStream, value: LogMessageTypeSeq): void;
        static read(ins: InputStream): LogMessageTypeSeq;
    }

    /**
     * A complete log message.
     */
    class LogMessage {
        constructor(type?: LogMessageType, timestamp?: Ice.Long, traceCategory?: string, message?: string);
        clone(): LogMessage;
        equals(rhs: any): boolean;
        hashCode(): number;
        type: LogMessageType;
        timestamp: Ice.Long;
        traceCategory: string;
        message: string;
        static write(outs: OutputStream, value: LogMessage): void;
        static read(ins: InputStream): LogMessage;
    }

    /**
     * A sequence of {@link LogMessage}.
     */
    type LogMessageSeq = LogMessage[];

    class LogMessageSeqHelper {
        static write(outs: OutputStream, value: LogMessageSeq): void;
        static read(ins: InputStream): LogMessageSeq;
    }

    abstract class RemoteLoggerPrx extends ObjectPrx {
        /**
         * init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
         * @param prefix The prefix of the associated local Logger.
         * @param logMessages Old log messages generated before "now".
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        init(prefix: string, logMessages: LogMessageSeq, context?: Map<string, string>): AsyncResult<void>;
        /**
         * Log a LogMessage. Note that log may be called by LoggerAdmin before init.
         * @param message The message to log.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        log(message: LogMessage, context?: Map<string, string>): AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): RemoteLoggerPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<RemoteLoggerPrx>;
    }

    abstract class RemoteLogger extends Object {
        /**
         * The Ice remote logger interface. An application can implement a
         * RemoteLogger to receive the log messages sent to the local {@link Logger}
         * of another Ice application.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract init(prefix: string, logMessages: LogMessageSeq, current: Current): PromiseLike<void> | void;
        /**
         * The Ice remote logger interface. An application can implement a
         * RemoteLogger to receive the log messages sent to the local {@link Logger}
         * of another Ice application.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract log(message: LogMessage, current: Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::RemoteLogger".
         */
        static ice_staticId(): string;
    }

    /**
     * Thrown when the provided RemoteLogger was previously attached to a LoggerAdmin.
     */
    class RemoteLoggerAlreadyAttachedException extends UserException {
    }

    abstract class LoggerAdminPrx extends ObjectPrx {
        /**
         * Attaches a RemoteLogger object to the local logger.
         * attachRemoteLogger calls init on the provided RemoteLogger proxy.
         * @param prx A proxy to the remote logger.
         * @param messageTypes The list of message types that the remote logger wishes to receive.
         * An empty list means no filtering (send all message types).
         * @param traceCategories The categories of traces that the remote logger wishes to receive.
         * This parameter is ignored if messageTypes is not empty and does not include trace.
         * An empty list means no filtering (send all trace categories).
         * @param messageMax The maximum number of log messages (of all types) to be provided
         * to init. A negative value requests all messages available.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        attachRemoteLogger(prx: RemoteLoggerPrx, messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: number, context?: Map<string, string>): AsyncResult<void>;
        /**
         * Detaches a RemoteLogger object from the local logger.
         * @param prx A proxy to the remote logger.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        detachRemoteLogger(prx: RemoteLoggerPrx, context?: Map<string, string>): AsyncResult<boolean>;
        /**
         * Retrieves log messages recently logged.
         * @param messageTypes The list of message types that the caller wishes to receive.
         * An empty list means no filtering (send all message types).
         * @param traceCategories The categories of traces that caller wish to receive.
         * This parameter is ignored if messageTypes is not empty and does not include trace.
         * An empty list means no filtering (send all trace categories).
         * @param messageMax The maximum number of log messages (of all types) to be returned.
         * A negative value requests all messages available.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLog(messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: number, context?: Map<string, string>): AsyncResult<[LogMessageSeq, string]>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): LoggerAdminPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<LoggerAdminPrx>;
    }

    abstract class LoggerAdmin extends Object {
        /**
         * The interface of the admin object that allows an Ice application the attach its
         * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract attachRemoteLogger(prx: RemoteLoggerPrx, messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: number, current: Current): PromiseLike<void> | void;
        /**
         * The interface of the admin object that allows an Ice application the attach its
         * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract detachRemoteLogger(prx: RemoteLoggerPrx, current: Current): PromiseLike<boolean> | boolean;
        /**
         * The interface of the admin object that allows an Ice application the attach its
         * {@link RemoteLogger} to the {@link Logger} of this admin object's Ice communicator.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getLog(messageTypes: LogMessageTypeSeq, traceCategories: StringSeq, messageMax: number, current: Current): PromiseLike<[LogMessageSeq, string]> | [LogMessageSeq, string];
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::LoggerAdmin".
         */
        static ice_staticId(): string;
    }
}

export namespace Ice {
    abstract class RouterPrx extends ObjectPrx {
        /**
         * Get the router's client proxy, i.e., the proxy to use for
         * forwarding requests from the client to the router.
         *
         * If a null proxy is returned, the client will forward requests
         * to the router's endpoints.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getClientProxy(context?: Map<string, string>): AsyncResult<[Ice.ObjectPrx, boolean]>;
        /**
         * Get the router's server proxy, i.e., the proxy to use for
         * forwarding requests from the server to the router.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerProxy(context?: Map<string, string>): AsyncResult<Ice.ObjectPrx>;
        /**
         * Add new proxy information to the router's routing table.
         * @param proxies The proxies to add.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addProxies(proxies: ObjectProxySeq, context?: Map<string, string>): AsyncResult<ObjectProxySeq>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): RouterPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<RouterPrx>;
    }

    abstract class Router extends Object {
        /**
         * The Ice router interface. Routers can be set either globally with
         * {@link Communicator#setDefaultRouter}, or with <code>ice_router</code> on specific
         * proxies.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getClientProxy(current: Current): PromiseLike<[Ice.ObjectPrx, boolean]> | [Ice.ObjectPrx, boolean];
        /**
         * The Ice router interface. Routers can be set either globally with
         * {@link Communicator#setDefaultRouter}, or with <code>ice_router</code> on specific
         * proxies.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerProxy(current: Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The Ice router interface. Routers can be set either globally with
         * {@link Communicator#setDefaultRouter}, or with <code>ice_router</code> on specific
         * proxies.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addProxies(proxies: ObjectProxySeq, current: Current): PromiseLike<ObjectProxySeq> | ObjectProxySeq;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::Router".
         */
        static ice_staticId(): string;
    }

    abstract class RouterFinderPrx extends ObjectPrx {
        /**
         * Get the router proxy implemented by the process hosting this
         * finder object. The proxy might point to several replicas.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRouter(context?: Map<string, string>): AsyncResult<RouterPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): RouterFinderPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<RouterFinderPrx>;
    }

    abstract class RouterFinder extends Object {
        /**
         * This inferface should be implemented by services implementing the
         * Ice::Router interface. It should be advertised through an Ice
         * object with the identity `Ice/RouterFinder'. This allows clients to
         * retrieve the router proxy with just the endpoint information of the
         * service.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRouter(current: Current): PromiseLike<RouterPrx> | RouterPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::RouterFinder".
         */
        static ice_staticId(): string;
    }
}

export namespace Ice {
}

export namespace Ice {
    /**
     * A servant locator is called by an object adapter to
     * locate a servant that is not found in its active servant map.
     * @see ObjectAdapter
     * @see ObjectAdapter#addServantLocator
     * @see ObjectAdapter#findServantLocator
     */
    interface ServantLocator {
        /**
         * Called before a request is dispatched if a
         * servant cannot be found in the object adapter's active servant
         * map. Note that the object adapter does not automatically insert
         * the returned servant into its active servant map. This must be
         * done by the servant locator implementation, if this is desired.
         *
         * <code>locate</code> can throw any user exception. If it does, that exception
         * is marshaled back to the client. If the Slice definition for the
         * corresponding operation includes that user exception, the client
         * receives that user exception; otherwise, the client receives
         * {@link UnknownUserException}.
         *
         * If <code>locate</code> throws any exception, the Ice run time does <em>not</em>
         * call <code>finished</code>.
         *
         * <p class="Note">If you call <code>locate</code> from your own code, you
         * must also call <code>finished</code> when you have finished using the
         * servant, provided that <code>locate</code> returned a non-null servant;
         * otherwise, you will get undefined behavior if you use
         * servant locators such as the Freeze Evictor.
         * @param curr Information about the current operation for which
         * a servant is required.
         * @param cookie A "cookie" that will be passed to <code>finished</code>.
         * @return The located servant, or null if no suitable servant has
         * been found.
         * @throws UserException The implementation can raise a UserException
         * and the run time will marshal it as the result of the invocation.
         * @see ObjectAdapter
         * @see Current
         * @see #finished
         */
        locate(curr: Current, cookie: Holder<Object>): Ice.Object;
        /**
         * Called by the object adapter after a request has been
         * made. This operation is only called if <code>locate</code> was called
         * prior to the request and returned a non-null servant. This
         * operation can be used for cleanup purposes after a request.
         *
         * <code>finished</code> can throw any user exception. If it does, that exception
         * is marshaled back to the client. If the Slice definition for the
         * corresponding operation includes that user exception, the client
         * receives that user exception; otherwise, the client receives
         * {@link UnknownUserException}.
         *
         * If both the operation and <code>finished</code> throw an exception, the
         * exception thrown by <code>finished</code> is marshaled back to the client.
         * @param curr Information about the current operation call for
         * which a servant was located by <code>locate</code>.
         * @param servant The servant that was returned by <code>locate</code>.
         * @param cookie The cookie that was returned by <code>locate</code>.
         * @throws UserException The implementation can raise a UserException
         * and the run time will marshal it as the result of the invocation.
         * @see ObjectAdapter
         * @see Current
         * @see #locate
         */
        finished(curr: Current, servant: Ice.Object, cookie: Object): void;
        /**
         * Called when the object adapter in which this servant locator is
         * installed is destroyed.
         * @param category Indicates for which category the servant locator
         * is being deactivated.
         * @see ObjectAdapter#destroy
         * @see Communicator#shutdown
         * @see Communicator#destroy
         */
        deactivate(category: string): void;
    }
}

export namespace Ice {
}

export namespace Ice {
    /**
     * A mapping from type IDs to Slice checksums. The dictionary
     * allows verification at run time that client and server
     * use matching Slice definitions.
     */
    class SliceChecksumDict extends Map<string, string>
    {
    }

    class SliceChecksumDictHelper {
        static write(outs: OutputStream, value: SliceChecksumDict): void;
        static read(ins: InputStream): SliceChecksumDict;
    }
}

export namespace Ice {
    /**
     * Create a new value for a given value type. The type is the
     * absolute Slice type id, i.e., the id relative to the
     * unnamed top-level Slice module. For example, the absolute
     * Slice type id for an interface <code>Bar</code> in the module
     * <code>Foo</code> is <code>"::Foo::Bar"</code>.
     *
     * Note that the leading "<code>::</code>" is required.
     * @param type The value type.
     * @return The value created for the given type, or nil if the
     * factory is unable to create the value.
     */
    type ValueFactory = (type: string) => Ice.Value;

    /**
     * A value factory manager maintains a collection of value factories.
     * An application can supply a custom implementation during communicator
     * initialization, otherwise Ice provides a default implementation.
     * @see ValueFactory
     */
    interface ValueFactoryManager {
        /**
         * Add a value factory. Attempting to add a factory with an id for
         * which a factory is already registered throws AlreadyRegisteredException.
         *
         * When unmarshaling an Ice value, the Ice run time reads the
         * most-derived type id off the wire and attempts to create an
         * instance of the type using a factory. If no instance is created,
         * either because no factory was found, or because all factories
         * returned nil, the behavior of the Ice run time depends on the
         * format with which the value was marshaled:
         *
         * If the value uses the "sliced" format, Ice ascends the class
         * hierarchy until it finds a type that is recognized by a factory,
         * or it reaches the least-derived type. If no factory is found that
         * can create an instance, the run time throws NoValueFactoryException.
         *
         * If the value uses the "compact" format, Ice immediately raises
         * NoValueFactoryException.
         *
         * The following order is used to locate a factory for a type:
         *
         * <ol>
         *
         * <li>The Ice run-time looks for a factory registered
         * specifically for the type.</li>
         *
         * <li>If no instance has been created, the Ice run-time looks
         * for the default factory, which is registered with an empty type id.
         * </li>
         *
         * <li>If no instance has been created by any of the preceding
         * steps, the Ice run-time looks for a factory that may have been
         * statically generated by the language mapping for non-abstract classes.
         * </li>
         *
         * </ol>
         * @param factory The factory to add.
         * @param id The type id for which the factory can create instances, or
         * an empty string for the default factory.
         */
        add(factory: Ice.ValueFactory, id: string): void;
        /**
         * Find an value factory registered with this communicator.
         * @param id The type id for which the factory can create instances,
         * or an empty string for the default factory.
         * @return The value factory, or null if no value factory was
         * found for the given id.
         */
        find(id: string): Ice.ValueFactory;
    }
}

export namespace Ice {
    /**
     * A version structure for the protocol version.
     */
    class ProtocolVersion {
        constructor(major?: number, minor?: number);
        clone(): ProtocolVersion;
        equals(rhs: any): boolean;
        hashCode(): number;
        major: number;
        minor: number;
        static write(outs: OutputStream, value: ProtocolVersion): void;
        static read(ins: InputStream): ProtocolVersion;
    }

    /**
     * A version structure for the encoding version.
     */
    class EncodingVersion {
        constructor(major?: number, minor?: number);
        clone(): EncodingVersion;
        equals(rhs: any): boolean;
        hashCode(): number;
        major: number;
        minor: number;
        static write(outs: OutputStream, value: EncodingVersion): void;
        static read(ins: InputStream): EncodingVersion;
    }
}

export namespace IceMX {
    /**
     * Provides information on Glacier2 sessions.
     */
    class SessionMetrics extends Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param forwardedClient Number of client requests forwared.
         * @param forwardedServer Number of server requests forwared.
         * @param routingTableSize The size of the routing table.
         * @param queuedClient Number of client requests queued.
         * @param queuedServer Number of server requests queued.
         * @param overriddenClient Number of client requests overridden.
         * @param overriddenServer Number of server requests overridden.
         */
        constructor(id?: string, total?: Ice.Long, current?: number, totalLifetime?: Ice.Long, failures?: number, forwardedClient?: number, forwardedServer?: number, routingTableSize?: number, queuedClient?: number, queuedServer?: number, overriddenClient?: number, overriddenServer?: number);
        /**
         * Number of client requests forwared.
         */
        forwardedClient: number;
        /**
         * Number of server requests forwared.
         */
        forwardedServer: number;
        /**
         * The size of the routing table.
         */
        routingTableSize: number;
        /**
         * Number of client requests queued.
         */
        queuedClient: number;
        /**
         * Number of server requests queued.
         */
        queuedServer: number;
        /**
         * Number of client requests overridden.
         */
        overriddenClient: number;
        /**
         * Number of server requests overridden.
         */
        overriddenServer: number;
    }
}

export namespace Glacier2 {
    /**
     * This exception is raised if a client is denied the ability to create
     * a session with the router.
     */
    class PermissionDeniedException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason why permission was denied.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    abstract class PermissionsVerifierPrx extends Ice.ObjectPrx {
        /**
         * Check whether a user has permission to access the router.
         * @param userId The user id for which to check permission.
         * @param password The user's password.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        checkPermissions(userId: string, password: string, context?: Map<string, string>): Ice.AsyncResult<[boolean, string]>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): PermissionsVerifierPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<PermissionsVerifierPrx>;
    }

    abstract class PermissionsVerifier extends Ice.Object {
        /**
         * The Glacier2 permissions verifier. This is called through the
         * process of establishing a session.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Router
         */
        abstract checkPermissions(userId: string, password: string, current: Ice.Current): PromiseLike<[boolean, string]> | [boolean, string];
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::PermissionsVerifier".
         */
        static ice_staticId(): string;
    }

    abstract class SSLPermissionsVerifierPrx extends Ice.ObjectPrx {
        /**
         * Check whether a user has permission to access the router.
         * @param info The SSL information.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see SSLInfo
         */
        authorize(info: SSLInfo, context?: Map<string, string>): Ice.AsyncResult<[boolean, string]>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): SSLPermissionsVerifierPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<SSLPermissionsVerifierPrx>;
    }

    abstract class SSLPermissionsVerifier extends Ice.Object {
        /**
         * The SSL Glacier2 permissions verifier. This is called through the
         * process of establishing a session.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Router
         */
        abstract authorize(info: SSLInfo, current: Ice.Current): PromiseLike<[boolean, string]> | [boolean, string];
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::SSLPermissionsVerifier".
         */
        static ice_staticId(): string;
    }
}

export namespace Glacier2 {
}

export namespace Glacier2 {
    /**
     * This exception is raised if a client tries to destroy a session
     * with a router, but no session exists for the client.
     * @see Router#destroySession
     */
    class SessionNotExistException extends Ice.UserException {
    }

    abstract class RouterPrx extends Ice.ObjectPrx {
        /**
         * Get the router's client proxy, i.e., the proxy to use for
         * forwarding requests from the client to the router.
         *
         * If a null proxy is returned, the client will forward requests
         * to the router's endpoints.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getClientProxy(context?: Map<string, string>): Ice.AsyncResult<[Ice.ObjectPrx, boolean]>;
        /**
         * Get the router's server proxy, i.e., the proxy to use for
         * forwarding requests from the server to the router.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerProxy(context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Add new proxy information to the router's routing table.
         * @param proxies The proxies to add.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addProxies(proxies: Ice.ObjectProxySeq, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectProxySeq>;
        /**
         * This category must be used in the identities of all of the client's
         * callback objects. This is necessary in order for the router to
         * forward callback requests to the intended client. If the Glacier2
         * server endpoints are not set, the returned category is an empty
         * string.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getCategoryForClient(context?: Map<string, string>): Ice.AsyncResult<string>;
        /**
         * Create a per-client session with the router. If a
         * {@link SessionManager} has been installed, a proxy to a {@link Session}
         * object is returned to the client. Otherwise, null is returned
         * and only an internal session (i.e., not visible to the client)
         * is created.
         *
         * If a session proxy is returned, it must be configured to route
         * through the router that created it. This will happen automatically
         * if the router is configured as the client's default router at the
         * time the session proxy is created in the client process, otherwise
         * the client must configure the session proxy explicitly.
         * @param userId The user id for which to check the password.
         * @param password The password for the given user id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see Session
         * @see SessionManager
         * @see PermissionsVerifier
         */
        createSession(userId: string, password: string, context?: Map<string, string>): Ice.AsyncResult<SessionPrx>;
        /**
         * Create a per-client session with the router. The user is
         * authenticated through the SSL certificates that have been
         * associated with the connection. If a {@link SessionManager} has been
         * installed, a proxy to a {@link Session} object is returned to the
         * client. Otherwise, null is returned and only an internal
         * session (i.e., not visible to the client) is created.
         *
         * If a session proxy is returned, it must be configured to route
         * through the router that created it. This will happen automatically
         * if the router is configured as the client's default router at the
         * time the session proxy is created in the client process, otherwise
         * the client must configure the session proxy explicitly.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see Session
         * @see SessionManager
         * @see PermissionsVerifier
         */
        createSessionFromSecureConnection(context?: Map<string, string>): Ice.AsyncResult<SessionPrx>;
        /**
         * Keep the calling client's session with this router alive.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        refreshSession(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Destroy the calling client's session with this router.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroySession(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get the value of the session timeout. Sessions are destroyed
         * if they see no activity for this period of time.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSessionTimeout(context?: Map<string, string>): Ice.AsyncResult<Ice.Long>;
        /**
         * Get the value of the ACM timeout. Clients supporting connection
         * heartbeats can enable them instead of explicitly sending keep
         * alives requests.
         *
         * NOTE: This method is only available since Ice 3.6.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getACMTimeout(context?: Map<string, string>): Ice.AsyncResult<number>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): RouterPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<RouterPrx>;
    }

    abstract class Router extends Ice.Object {
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getClientProxy(current: Ice.Current): PromiseLike<[Ice.ObjectPrx, boolean]> | [Ice.ObjectPrx, boolean];
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerProxy(current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addProxies(proxies: Ice.ObjectProxySeq, current: Ice.Current): PromiseLike<Ice.ObjectProxySeq> | Ice.ObjectProxySeq;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getCategoryForClient(current: Ice.Current): PromiseLike<string> | string;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract createSession(userId: string, password: string, current: Ice.Current): PromiseLike<SessionPrx> | SessionPrx;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract createSessionFromSecureConnection(current: Ice.Current): PromiseLike<SessionPrx> | SessionPrx;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract refreshSession(current: Ice.Current): PromiseLike<void> | void;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract destroySession(current: Ice.Current): PromiseLike<void> | void;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getSessionTimeout(current: Ice.Current): PromiseLike<Ice.Long> | Ice.Long;
        /**
         * The Glacier2 specialization of the <code>Ice::Router</code> interface.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getACMTimeout(current: Ice.Current): PromiseLike<number> | number;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::Router".
         */
        static ice_staticId(): string;
    }
}

export namespace Glacier2 {
}

export namespace Glacier2 {
    /**
     * Information taken from an SSL connection used for permissions
     * verification.
     * @see PermissionsVerifier
     */
    class SSLInfo {
        constructor(remoteHost?: string, remotePort?: number, localHost?: string, localPort?: number, cipher?: string, certs?: Ice.StringSeq);
        clone(): SSLInfo;
        equals(rhs: any): boolean;
        hashCode(): number;
        remoteHost: string;
        remotePort: number;
        localHost: string;
        localPort: number;
        cipher: string;
        certs: Ice.StringSeq;
        static write(outs: Ice.OutputStream, value: SSLInfo): void;
        static read(ins: Ice.InputStream): SSLInfo;
    }
}

export namespace Glacier2 {
    /**
     * This exception is raised if an attempt to create a new session failed.
     */
    class CannotCreateSessionException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason why session creation has failed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    abstract class SessionPrx extends Ice.ObjectPrx {
        /**
         * Destroy the session. This is called automatically when the router is destroyed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroy(context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): SessionPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<SessionPrx>;
    }

    abstract class Session extends Ice.Object {
        /**
         * A client-visible session object, which is tied to the lifecycle of a {@link Router}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Router
         * @see SessionManager
         */
        abstract destroy(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::Session".
         */
        static ice_staticId(): string;
    }

    abstract class StringSetPrx extends Ice.ObjectPrx {
        /**
         * Add a sequence of strings to this set of constraints. Order is
         * not preserved and duplicates are implicitly removed.
         * @param additions The sequence of strings to be added.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        add(additions: Ice.StringSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Remove a sequence of strings from this set of constraints. No
         * errors are returned if an entry is not found.
         * @param deletions The sequence of strings to be removed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        remove(deletions: Ice.StringSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Returns a sequence of strings describing the constraints in this
         * set.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        get(context?: Map<string, string>): Ice.AsyncResult<Ice.StringSeq>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): StringSetPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<StringSetPrx>;
    }

    abstract class StringSet extends Ice.Object {
        /**
         * An object for managing the set of identity constraints for specific
         * parts of object identity on a
         * {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see SessionControl
         */
        abstract add(additions: Ice.StringSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * An object for managing the set of identity constraints for specific
         * parts of object identity on a
         * {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see SessionControl
         */
        abstract remove(deletions: Ice.StringSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * An object for managing the set of identity constraints for specific
         * parts of object identity on a
         * {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see SessionControl
         */
        abstract get(current: Ice.Current): PromiseLike<Ice.StringSeq> | Ice.StringSeq;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::StringSet".
         */
        static ice_staticId(): string;
    }

    abstract class IdentitySetPrx extends Ice.ObjectPrx {
        /**
         * Add a sequence of Ice identities to this set of constraints. Order is
         * not preserved and duplicates are implicitly removed.
         * @param additions The sequence of Ice identities to be added.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        add(additions: Ice.IdentitySeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Remove a sequence of identities from this set of constraints. No
         * errors are returned if an entry is not found.
         * @param deletions The sequence of Ice identities to be removed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        remove(deletions: Ice.IdentitySeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Returns a sequence of identities describing the constraints in this
         * set.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        get(context?: Map<string, string>): Ice.AsyncResult<Ice.IdentitySeq>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): IdentitySetPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<IdentitySetPrx>;
    }

    abstract class IdentitySet extends Ice.Object {
        /**
         * An object for managing the set of object identity constraints on a
         * {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see SessionControl
         */
        abstract add(additions: Ice.IdentitySeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * An object for managing the set of object identity constraints on a
         * {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see SessionControl
         */
        abstract remove(deletions: Ice.IdentitySeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * An object for managing the set of object identity constraints on a
         * {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see SessionControl
         */
        abstract get(current: Ice.Current): PromiseLike<Ice.IdentitySeq> | Ice.IdentitySeq;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::IdentitySet".
         */
        static ice_staticId(): string;
    }

    abstract class SessionControlPrx extends Ice.ObjectPrx {
        /**
         * Access the object that manages the allowable categories
         * for object identities for this session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        categories(context?: Map<string, string>): Ice.AsyncResult<StringSetPrx>;
        /**
         * Access the object that manages the allowable adapter identities
         * for objects for this session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        adapterIds(context?: Map<string, string>): Ice.AsyncResult<StringSetPrx>;
        /**
         * Access the object that manages the allowable object identities
         * for this session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        identities(context?: Map<string, string>): Ice.AsyncResult<IdentitySetPrx>;
        /**
         * Get the session timeout.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSessionTimeout(context?: Map<string, string>): Ice.AsyncResult<number>;
        /**
         * Destroy the associated session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroy(context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): SessionControlPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<SessionControlPrx>;
    }

    abstract class SessionControl extends Ice.Object {
        /**
         * An administrative session control object, which is tied to the
         * lifecycle of a {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         */
        abstract categories(current: Ice.Current): PromiseLike<StringSetPrx> | StringSetPrx;
        /**
         * An administrative session control object, which is tied to the
         * lifecycle of a {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         */
        abstract adapterIds(current: Ice.Current): PromiseLike<StringSetPrx> | StringSetPrx;
        /**
         * An administrative session control object, which is tied to the
         * lifecycle of a {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         */
        abstract identities(current: Ice.Current): PromiseLike<IdentitySetPrx> | IdentitySetPrx;
        /**
         * An administrative session control object, which is tied to the
         * lifecycle of a {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         */
        abstract getSessionTimeout(current: Ice.Current): PromiseLike<number> | number;
        /**
         * An administrative session control object, which is tied to the
         * lifecycle of a {@link Session}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         */
        abstract destroy(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::SessionControl".
         */
        static ice_staticId(): string;
    }

    abstract class SessionManagerPrx extends Ice.ObjectPrx {
        /**
         * Create a new session.
         * @param userId The user id for the session.
         * @param control A proxy to the session control object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        create(userId: string, control: SessionControlPrx, context?: Map<string, string>): Ice.AsyncResult<SessionPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): SessionManagerPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<SessionManagerPrx>;
    }

    abstract class SessionManager extends Ice.Object {
        /**
         * The session manager for username/password authenticated users that
         * is responsible for managing {@link Session} objects. New session objects
         * are created by the {@link Router} object calling on an application-provided
         * session manager. If no session manager is provided by the application,
         * no client-visible sessions are passed to the client.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Router
         * @see Session
         */
        abstract create(userId: string, control: SessionControlPrx, current: Ice.Current): PromiseLike<SessionPrx> | SessionPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::SessionManager".
         */
        static ice_staticId(): string;
    }

    abstract class SSLSessionManagerPrx extends Ice.ObjectPrx {
        /**
         * Create a new session.
         * @param info The SSL info.
         * @param control A proxy to the session control object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        create(info: SSLInfo, control: SessionControlPrx, context?: Map<string, string>): Ice.AsyncResult<SessionPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): SSLSessionManagerPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<SSLSessionManagerPrx>;
    }

    abstract class SSLSessionManager extends Ice.Object {
        /**
         * The session manager for SSL authenticated users that is
         * responsible for managing {@link Session} objects. New session objects are
         * created by the {@link Router} object calling on an application-provided
         * session manager. If no session manager is provided by the
         * application, no client-visible sessions are passed to the client.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Router
         * @see Session
         */
        abstract create(info: SSLInfo, control: SessionControlPrx, current: Ice.Current): PromiseLike<SessionPrx> | SessionPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Glacier2::SSLSessionManager".
         */
        static ice_staticId(): string;
    }
}

export namespace IceStorm {
    /**
     * Information on the topic links.
     */
    class LinkInfo {
        constructor(theTopic?: TopicPrx, name?: string, cost?: number);
        clone(): LinkInfo;
        equals(rhs: any): boolean;
        theTopic: TopicPrx;
        name: string;
        cost: number;
        static write(outs: Ice.OutputStream, value: LinkInfo): void;
        static read(ins: Ice.InputStream): LinkInfo;
    }

    /**
     * A sequence of {@link LinkInfo} objects.
     */
    type LinkInfoSeq = LinkInfo[];

    class LinkInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: LinkInfoSeq): void;
        static read(ins: Ice.InputStream): LinkInfoSeq;
    }

    /**
     * This dictionary represents quality of service parameters.
     * @see Topic#subscribeAndGetPublisher
     */
    class QoS extends Map<string, string>
    {
    }

    class QoSHelper {
        static write(outs: Ice.OutputStream, value: QoS): void;
        static read(ins: Ice.InputStream): QoS;
    }

    /**
     * This exception indicates that an attempt was made to create a link
     * that already exists.
     */
    class LinkExists extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the linked topic.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * This exception indicates that an attempt was made to remove a
     * link that does not exist.
     */
    class NoSuchLink extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the link that does not exist.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * This exception indicates that an attempt was made to subscribe
     * a proxy for which a subscription already exists.
     */
    class AlreadySubscribed extends Ice.UserException {
    }

    /**
     * This exception indicates that an attempt was made to subscribe
     * a proxy that is null.
     */
    class InvalidSubscriber extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception indicates that a subscription failed due to an
     * invalid QoS.
     */
    class BadQoS extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    abstract class TopicPrx extends Ice.ObjectPrx {
        /**
         * Get the name of this topic.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see TopicManager#create
         */
        getName(context?: Map<string, string>): Ice.AsyncResult<string>;
        /**
         * Get a proxy to a publisher object for this topic. To publish
         * data to a topic, the publisher calls getPublisher and then
         * casts to the topic type. An unchecked cast must be used on this
         * proxy. If a replicated IceStorm deployment is used this call
         * may return a replicated proxy.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getPublisher(context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Get a non-replicated proxy to a publisher object for this
         * topic. To publish data to a topic, the publisher calls
         * getPublisher and then casts to the topic type. An unchecked
         * cast must be used on this proxy.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getNonReplicatedPublisher(context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Subscribe with the given <code>qos</code> to this topic.  A
         * per-subscriber publisher object is returned.
         * @param theQoS The quality of service parameters for this
         * subscription.
         * @param subscriber The subscriber's proxy.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see #unsubscribe
         */
        subscribeAndGetPublisher(theQoS: QoS, subscriber: Ice.ObjectPrx, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Unsubscribe the given <code>subscriber</code>.
         * @param subscriber The proxy of an existing subscriber.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see #subscribeAndGetPublisher
         */
        unsubscribe(subscriber: Ice.ObjectPrx, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Create a link to the given topic. All events originating
         * on this topic will also be sent to <code>linkTo</code>.
         * @param linkTo The topic to link to.
         * @param cost The cost to the linked topic.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        link(linkTo: TopicPrx, cost: number, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Destroy the link from this topic to the given topic <code>linkTo</code>.
         * @param linkTo The topic to destroy the link to.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        unlink(linkTo: TopicPrx, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Retrieve information on the current links.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLinkInfoSeq(context?: Map<string, string>): Ice.AsyncResult<LinkInfoSeq>;
        /**
         * Retrieve the list of subscribers for this topic.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSubscribers(context?: Map<string, string>): Ice.AsyncResult<Ice.IdentitySeq>;
        /**
         * Destroy the topic.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroy(context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): TopicPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<TopicPrx>;
    }

    abstract class Topic extends Ice.Object {
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract getName(current: Ice.Current): PromiseLike<string> | string;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract getPublisher(current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract getNonReplicatedPublisher(current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract subscribeAndGetPublisher(theQoS: QoS, subscriber: Ice.ObjectPrx, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract unsubscribe(subscriber: Ice.ObjectPrx, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract link(linkTo: TopicPrx, cost: number, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract unlink(linkTo: TopicPrx, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract getLinkInfoSeq(current: Ice.Current): PromiseLike<LinkInfoSeq> | LinkInfoSeq;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract getSubscribers(current: Ice.Current): PromiseLike<Ice.IdentitySeq> | Ice.IdentitySeq;
        /**
         * Publishers publish information on a particular topic. A topic
         * logically represents a type.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see TopicManager
         */
        abstract destroy(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceStorm::Topic".
         */
        static ice_staticId(): string;
    }

    /**
     * Mapping of topic name to topic proxy.
     */
    class TopicDict extends Map<string, TopicPrx>
    {
    }

    class TopicDictHelper {
        static write(outs: Ice.OutputStream, value: TopicDict): void;
        static read(ins: Ice.InputStream): TopicDict;
    }

    /**
     * This exception indicates that an attempt was made to create a topic
     * that already exists.
     */
    class TopicExists extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the topic that already exists.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * This exception indicates that an attempt was made to retrieve a
     * topic that does not exist.
     */
    class NoSuchTopic extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the topic that does not exist.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    abstract class TopicManagerPrx extends Ice.ObjectPrx {
        /**
         * Create a new topic. The topic name must be unique.
         * @param name The name of the topic.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        create(name: string, context?: Map<string, string>): Ice.AsyncResult<TopicPrx>;
        /**
         * Retrieve a topic by name.
         * @param name The name of the topic.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        retrieve(name: string, context?: Map<string, string>): Ice.AsyncResult<TopicPrx>;
        /**
         * Retrieve all topics managed by this topic manager.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        retrieveAll(context?: Map<string, string>): Ice.AsyncResult<TopicDict>;
        /**
         * Returns the checksums for the IceStorm Slice definitions.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSliceChecksums(context?: Map<string, string>): Ice.AsyncResult<Ice.SliceChecksumDict>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): TopicManagerPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<TopicManagerPrx>;
    }

    abstract class TopicManager extends Ice.Object {
        /**
         * A topic manager manages topics, and subscribers to topics.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Topic
         */
        abstract create(name: string, current: Ice.Current): PromiseLike<TopicPrx> | TopicPrx;
        /**
         * A topic manager manages topics, and subscribers to topics.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Topic
         */
        abstract retrieve(name: string, current: Ice.Current): PromiseLike<TopicPrx> | TopicPrx;
        /**
         * A topic manager manages topics, and subscribers to topics.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Topic
         */
        abstract retrieveAll(current: Ice.Current): PromiseLike<TopicDict> | TopicDict;
        /**
         * A topic manager manages topics, and subscribers to topics.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Topic
         */
        abstract getSliceChecksums(current: Ice.Current): PromiseLike<Ice.SliceChecksumDict> | Ice.SliceChecksumDict;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceStorm::TopicManager".
         */
        static ice_staticId(): string;
    }

    abstract class FinderPrx extends Ice.ObjectPrx {
        /**
         * Get the topic manager proxy. The proxy might point to several
         * replicas.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getTopicManager(context?: Map<string, string>): Ice.AsyncResult<TopicManagerPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): FinderPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<FinderPrx>;
    }

    abstract class Finder extends Ice.Object {
        /**
         * This inferface is advertised by the IceStorm service through the
         * Ice object with the identity `IceStorm/Finder'. This allows clients
         * to retrieve the topic manager with just the endpoint information of
         * the IceStorm service.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getTopicManager(current: Ice.Current): PromiseLike<TopicManagerPrx> | TopicManagerPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceStorm::Finder".
         */
        static ice_staticId(): string;
    }
}

export namespace IceMX {
    /**
     * Provides information on IceStorm topics.
     */
    class TopicMetrics extends iceNS0.IceMX.Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param published Number of events published on the topic by publishers.
         * @param forwarded Number of events forwarded on the topic by IceStorm topic links.
         */
        constructor(id?: string, total?: iceNS0.Ice.Long, current?: number, totalLifetime?: iceNS0.Ice.Long, failures?: number, published?: iceNS0.Ice.Long, forwarded?: iceNS0.Ice.Long);
        /**
         * Number of events published on the topic by publishers.
         */
        published: iceNS0.Ice.Long;
        /**
         * Number of events forwarded on the topic by IceStorm topic links.
         */
        forwarded: iceNS0.Ice.Long;
    }

    /**
     * Provides information on IceStorm subscribers.
     */
    class SubscriberMetrics extends iceNS0.IceMX.Metrics {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The metrics identifier.
         * @param total The total number of objects that were observed by this metrics.
         * @param current The current number of objects observed by this metrics.
         * @param totalLifetime The sum of the lifetime of each observed objects.
         * @param failures The number of failures observed.
         * @param queued Number of queued events.
         * @param outstanding Number of outstanding events.
         * @param delivered Number of forwarded events.
         */
        constructor(id?: string, total?: iceNS0.Ice.Long, current?: number, totalLifetime?: iceNS0.Ice.Long, failures?: number, queued?: number, outstanding?: number, delivered?: iceNS0.Ice.Long);
        /**
         * Number of queued events.
         */
        queued: number;
        /**
         * Number of outstanding events.
         */
        outstanding: number;
        /**
         * Number of forwarded events.
         */
        delivered: iceNS0.Ice.Long;
    }
}

export namespace IceGrid {
    /**
     * An enumeration representing the state of the server.
     */
    class ServerState {
        /**
         * The server is not running.
         */
        static readonly Inactive: ServerState;
        /**
         * The server is being activated and will change to the active
         * state when the registered server object adapters are activated
         * or to the activation timed out state if the activation timeout
         * expires.
         */
        static readonly Activating: ServerState;
        /**
         * The activation timed out state indicates that the server
         * activation timed out.
         */
        static readonly ActivationTimedOut: ServerState;
        /**
         * The server is running.
         */
        static readonly Active: ServerState;
        /**
         * The server is being deactivated.
         */
        static readonly Deactivating: ServerState;
        /**
         * The server is being destroyed.
         */
        static readonly Destroying: ServerState;
        /**
         * The server is destroyed.
         */
        static readonly Destroyed: ServerState;

        static valueOf(value: number): ServerState;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    /**
     * A dictionary of proxies.
     */
    class StringObjectProxyDict extends Map<string, Ice.ObjectPrx>
    {
    }

    class StringObjectProxyDictHelper {
        static write(outs: Ice.OutputStream, value: StringObjectProxyDict): void;
        static read(ins: Ice.InputStream): StringObjectProxyDict;
    }

    /**
     * Information about an Ice object.
     */
    class ObjectInfo {
        constructor(proxy?: Ice.ObjectPrx, type?: string);
        clone(): ObjectInfo;
        equals(rhs: any): boolean;
        proxy: Ice.ObjectPrx;
        type: string;
        static write(outs: Ice.OutputStream, value: ObjectInfo): void;
        static read(ins: Ice.InputStream): ObjectInfo;
    }

    /**
     * A sequence of object information structures.
     */
    type ObjectInfoSeq = ObjectInfo[];

    class ObjectInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: ObjectInfoSeq): void;
        static read(ins: Ice.InputStream): ObjectInfoSeq;
    }

    /**
     * Information about an adapter registered with the IceGrid registry.
     */
    class AdapterInfo {
        constructor(id?: string, proxy?: Ice.ObjectPrx, replicaGroupId?: string);
        clone(): AdapterInfo;
        equals(rhs: any): boolean;
        id: string;
        proxy: Ice.ObjectPrx;
        replicaGroupId: string;
        static write(outs: Ice.OutputStream, value: AdapterInfo): void;
        static read(ins: Ice.InputStream): AdapterInfo;
    }

    /**
     * A sequence of adapter information structures.
     */
    type AdapterInfoSeq = AdapterInfo[];

    class AdapterInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: AdapterInfoSeq): void;
        static read(ins: Ice.InputStream): AdapterInfoSeq;
    }

    /**
     * Information about a server managed by an IceGrid node.
     */
    class ServerInfo {
        constructor(application?: string, uuid?: string, revision?: number, node?: string, descriptor?: IceGrid.ServerDescriptor, sessionId?: string);
        clone(): ServerInfo;
        equals(rhs: any): boolean;
        application: string;
        uuid: string;
        revision: number;
        node: string;
        descriptor: IceGrid.ServerDescriptor;
        sessionId: string;
        static write(outs: Ice.OutputStream, value: ServerInfo): void;
        static read(ins: Ice.InputStream): ServerInfo;
    }

    /**
     * Information about an IceGrid node.
     */
    class NodeInfo {
        constructor(name?: string, os?: string, hostname?: string, release?: string, version?: string, machine?: string, nProcessors?: number, dataDir?: string);
        clone(): NodeInfo;
        equals(rhs: any): boolean;
        hashCode(): number;
        name: string;
        os: string;
        hostname: string;
        release: string;
        version: string;
        machine: string;
        nProcessors: number;
        dataDir: string;
        static write(outs: Ice.OutputStream, value: NodeInfo): void;
        static read(ins: Ice.InputStream): NodeInfo;
    }

    /**
     * Information about an IceGrid registry replica.
     */
    class RegistryInfo {
        constructor(name?: string, hostname?: string);
        clone(): RegistryInfo;
        equals(rhs: any): boolean;
        hashCode(): number;
        name: string;
        hostname: string;
        static write(outs: Ice.OutputStream, value: RegistryInfo): void;
        static read(ins: Ice.InputStream): RegistryInfo;
    }

    /**
     * A sequence of {@link RegistryInfo} structures.
     */
    type RegistryInfoSeq = RegistryInfo[];

    class RegistryInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: RegistryInfoSeq): void;
        static read(ins: Ice.InputStream): RegistryInfoSeq;
    }

    /**
     * Information about the load of a node.
     */
    class LoadInfo {
        constructor(avg1?: number, avg5?: number, avg15?: number);
        clone(): LoadInfo;
        equals(rhs: any): boolean;
        avg1: number;
        avg5: number;
        avg15: number;
        static write(outs: Ice.OutputStream, value: LoadInfo): void;
        static read(ins: Ice.InputStream): LoadInfo;
    }

    /**
     * Information about an IceGrid application.
     */
    class ApplicationInfo {
        constructor(uuid?: string, createTime?: Ice.Long, createUser?: string, updateTime?: Ice.Long, updateUser?: string, revision?: number, descriptor?: ApplicationDescriptor);
        clone(): ApplicationInfo;
        equals(rhs: any): boolean;
        uuid: string;
        createTime: Ice.Long;
        createUser: string;
        updateTime: Ice.Long;
        updateUser: string;
        revision: number;
        descriptor: ApplicationDescriptor;
        static write(outs: Ice.OutputStream, value: ApplicationInfo): void;
        static read(ins: Ice.InputStream): ApplicationInfo;
    }

    /**
     * A sequence of {@link ApplicationInfo} structures.
     */
    type ApplicationInfoSeq = ApplicationInfo[];

    class ApplicationInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: ApplicationInfoSeq): void;
        static read(ins: Ice.InputStream): ApplicationInfoSeq;
    }

    /**
     * Information about updates to an IceGrid application.
     */
    class ApplicationUpdateInfo {
        constructor(updateTime?: Ice.Long, updateUser?: string, revision?: number, descriptor?: ApplicationUpdateDescriptor);
        clone(): ApplicationUpdateInfo;
        equals(rhs: any): boolean;
        updateTime: Ice.Long;
        updateUser: string;
        revision: number;
        descriptor: ApplicationUpdateDescriptor;
        static write(outs: Ice.OutputStream, value: ApplicationUpdateInfo): void;
        static read(ins: Ice.InputStream): ApplicationUpdateInfo;
    }

    abstract class AdminPrx extends Ice.ObjectPrx {
        /**
         * Add an application to IceGrid.
         * @param descriptor The application descriptor.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addApplication(descriptor: ApplicationDescriptor, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Synchronize a deployed application with the given application
         * descriptor. This operation will replace the current descriptor
         * with this new descriptor.
         * @param descriptor The application descriptor.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        syncApplication(descriptor: ApplicationDescriptor, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Update a deployed application with the given update application
         * descriptor.
         * @param descriptor The update descriptor.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateApplication(descriptor: ApplicationUpdateDescriptor, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Synchronize a deployed application with the given application
         * descriptor. This operation will replace the current descriptor
         * with this new descriptor only if no server restarts are
         * necessary for the update of the application. If some servers
         * need to be restarted, the synchronization is rejected with a
         * DeploymentException.
         * @param descriptor The application descriptor.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        syncApplicationWithoutRestart(descriptor: ApplicationDescriptor, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Update a deployed application with the given update application
         * descriptor only if no server restarts are necessary for the
         * update of the application. If some servers need to be
         * restarted, the synchronization is rejected with a
         * DeploymentException.
         * @param descriptor The update descriptor.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateApplicationWithoutRestart(descriptor: ApplicationUpdateDescriptor, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Remove an application from IceGrid.
         * @param name The application name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        removeApplication(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Instantiate a server template from an application on the given
         * node.
         * @param application The application name.
         * @param node The name of the node where the server will be
         * deployed.
         * @param desc The descriptor of the server instance to deploy.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        instantiateServer(application: string, node: string, desc: ServerInstanceDescriptor, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Patch the given application data.
         * @param name The application name.
         * @param shutdown If true, the servers depending on the data to
         * patch will be shut down if necessary.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        patchApplication(name: string, shutdown: boolean, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get an application descriptor.
         * @param name The application name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getApplicationInfo(name: string, context?: Map<string, string>): Ice.AsyncResult<ApplicationInfo>;
        /**
         * Get the default application descriptor.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getDefaultApplicationDescriptor(context?: Map<string, string>): Ice.AsyncResult<ApplicationDescriptor>;
        /**
         * Get all the IceGrid applications currently registered.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllApplicationNames(context?: Map<string, string>): Ice.AsyncResult<Ice.StringSeq>;
        /**
         * Get the server information for the server with the given id.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerInfo(id: string, context?: Map<string, string>): Ice.AsyncResult<ServerInfo>;
        /**
         * Get a server's state.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerState(id: string, context?: Map<string, string>): Ice.AsyncResult<ServerState>;
        /**
         * Get a server's system process id. The process id is operating
         * system dependent.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerPid(id: string, context?: Map<string, string>): Ice.AsyncResult<number>;
        /**
         * Get the category for server admin objects. You can manufacture a server admin
         * proxy from the admin proxy by changing its identity: use the server ID as name
         * and the returned category as category.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerAdminCategory(context?: Map<string, string>): Ice.AsyncResult<string>;
        /**
         * Get a proxy to the server's admin object.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServerAdmin(id: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Enable or disable a server. A disabled server can't be started
         * on demand or administratively. The enable state of the server
         * is not persistent: if the node is shut down and restarted, the
         * server will be enabled by default.
         * @param id The server id.
         * @param enabled True to enable the server, false to disable it.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        enableServer(id: string, enabled: boolean, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Check if the server is enabled or disabled.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        isServerEnabled(id: string, context?: Map<string, string>): Ice.AsyncResult<boolean>;
        /**
         * Start a server and wait for its activation.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        startServer(id: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Stop a server.
         * @param id The server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        stopServer(id: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Patch a server.
         * @param id The server id.
         * @param shutdown If true, servers depending on the data to patch
         * will be shut down if necessary.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        patchServer(id: string, shutdown: boolean, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Send signal to a server.
         * @param id The server id.
         * @param signal The signal, for example SIGTERM or 15.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        sendSignal(id: string, signal: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get all the server ids registered with IceGrid.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllServerIds(context?: Map<string, string>): Ice.AsyncResult<Ice.StringSeq>;
        /**
         * Get the adapter information for the replica group or adapter
         * with the given id.
         * @param id The adapter id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAdapterInfo(id: string, context?: Map<string, string>): Ice.AsyncResult<AdapterInfoSeq>;
        /**
         * Remove the adapter with the given id.
         * @param id The adapter id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        removeAdapter(id: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get all the adapter ids registered with IceGrid.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllAdapterIds(context?: Map<string, string>): Ice.AsyncResult<Ice.StringSeq>;
        /**
         * Add an object to the object registry. IceGrid will get the
         * object type by calling <code>ice_id</code> on the given proxy. The object
         * must be reachable.
         * @param obj The object to be added to the registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addObject(obj: Ice.ObjectPrx, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Update an object in the object registry. Only objects added
         * with this interface can be updated with this operation. Objects
         * added with deployment descriptors should be updated with the
         * deployment mechanism.
         * @param obj The object to be updated to the registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateObject(obj: Ice.ObjectPrx, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Add an object to the object registry and explicitly specify
         * its type.
         * @param obj The object to be added to the registry.
         * @param type The object type.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addObjectWithType(obj: Ice.ObjectPrx, type: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Remove an object from the object registry. Only objects added
         * with this interface can be removed with this operation. Objects
         * added with deployment descriptors should be removed with the
         * deployment mechanism.
         * @param id The identity of the object to be removed from the
         * registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        removeObject(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get the object info for the object with the given identity.
         * @param id The identity of the object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getObjectInfo(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<ObjectInfo>;
        /**
         * Get the object info of all the registered objects with the
         * given type.
         * @param type The type of the object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getObjectInfosByType(type: string, context?: Map<string, string>): Ice.AsyncResult<ObjectInfoSeq>;
        /**
         * Get the object info of all the registered objects whose stringified
         * identities match the given expression.
         * @param expr The expression to match against the stringified
         * identities of registered objects. The expression may contain
         * a trailing wildcard (<code>*</code>) character.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllObjectInfos(expr: string, context?: Map<string, string>): Ice.AsyncResult<ObjectInfoSeq>;
        /**
         * Ping an IceGrid node to see if it is active.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        pingNode(name: string, context?: Map<string, string>): Ice.AsyncResult<boolean>;
        /**
         * Get the load averages of the node.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getNodeLoad(name: string, context?: Map<string, string>): Ice.AsyncResult<LoadInfo>;
        /**
         * Get the node information for the node with the given name.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getNodeInfo(name: string, context?: Map<string, string>): Ice.AsyncResult<NodeInfo>;
        /**
         * Get a proxy to the IceGrid node's admin object.
         * @param name The IceGrid node name
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getNodeAdmin(name: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Get the number of physical processor sockets for the machine
         * running the node with the given name.
         *
         * Note that this method will return 1 on operating systems where
         * this can't be automatically determined and where the
         * IceGrid.Node.ProcessorSocketCount property for the node is not
         * set.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getNodeProcessorSocketCount(name: string, context?: Map<string, string>): Ice.AsyncResult<number>;
        /**
         * Shutdown an IceGrid node.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        shutdownNode(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get the hostname of this node.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getNodeHostname(name: string, context?: Map<string, string>): Ice.AsyncResult<string>;
        /**
         * Get all the IceGrid nodes currently registered.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllNodeNames(context?: Map<string, string>): Ice.AsyncResult<Ice.StringSeq>;
        /**
         * Ping an IceGrid registry to see if it is active.
         * @param name The registry name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        pingRegistry(name: string, context?: Map<string, string>): Ice.AsyncResult<boolean>;
        /**
         * Get the registry information for the registry with the given name.
         * @param name The registry name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegistryInfo(name: string, context?: Map<string, string>): Ice.AsyncResult<RegistryInfo>;
        /**
         * Get a proxy to the IceGrid registry's admin object.
         * @param name The registry name
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegistryAdmin(name: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Shutdown an IceGrid registry.
         * @param name The registry name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        shutdownRegistry(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get all the IceGrid registries currently registered.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllRegistryNames(context?: Map<string, string>): Ice.AsyncResult<Ice.StringSeq>;
        /**
         * Shut down the IceGrid registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        shutdown(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Returns the checksums for the IceGrid Slice definitions.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSliceChecksums(context?: Map<string, string>): Ice.AsyncResult<Ice.SliceChecksumDict>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): AdminPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<AdminPrx>;
    }

    abstract class Admin extends Ice.Object {
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addApplication(descriptor: ApplicationDescriptor, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract syncApplication(descriptor: ApplicationDescriptor, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateApplication(descriptor: ApplicationUpdateDescriptor, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract syncApplicationWithoutRestart(descriptor: ApplicationDescriptor, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateApplicationWithoutRestart(descriptor: ApplicationUpdateDescriptor, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeApplication(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract instantiateServer(application: string, node: string, desc: ServerInstanceDescriptor, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract patchApplication(name: string, shutdown: boolean, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getApplicationInfo(name: string, current: Ice.Current): PromiseLike<ApplicationInfo> | ApplicationInfo;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getDefaultApplicationDescriptor(current: Ice.Current): PromiseLike<ApplicationDescriptor> | ApplicationDescriptor;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllApplicationNames(current: Ice.Current): PromiseLike<Ice.StringSeq> | Ice.StringSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerInfo(id: string, current: Ice.Current): PromiseLike<ServerInfo> | ServerInfo;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerState(id: string, current: Ice.Current): PromiseLike<ServerState> | ServerState;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerPid(id: string, current: Ice.Current): PromiseLike<number> | number;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerAdminCategory(current: Ice.Current): PromiseLike<string> | string;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServerAdmin(id: string, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract enableServer(id: string, enabled: boolean, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract isServerEnabled(id: string, current: Ice.Current): PromiseLike<boolean> | boolean;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract startServer(id: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract stopServer(id: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract patchServer(id: string, shutdown: boolean, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract sendSignal(id: string, signal: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllServerIds(current: Ice.Current): PromiseLike<Ice.StringSeq> | Ice.StringSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAdapterInfo(id: string, current: Ice.Current): PromiseLike<AdapterInfoSeq> | AdapterInfoSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeAdapter(id: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllAdapterIds(current: Ice.Current): PromiseLike<Ice.StringSeq> | Ice.StringSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addObject(obj: Ice.ObjectPrx, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateObject(obj: Ice.ObjectPrx, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addObjectWithType(obj: Ice.ObjectPrx, type: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeObject(id: Ice.Identity, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getObjectInfo(id: Ice.Identity, current: Ice.Current): PromiseLike<ObjectInfo> | ObjectInfo;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getObjectInfosByType(type: string, current: Ice.Current): PromiseLike<ObjectInfoSeq> | ObjectInfoSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllObjectInfos(expr: string, current: Ice.Current): PromiseLike<ObjectInfoSeq> | ObjectInfoSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract pingNode(name: string, current: Ice.Current): PromiseLike<boolean> | boolean;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getNodeLoad(name: string, current: Ice.Current): PromiseLike<LoadInfo> | LoadInfo;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getNodeInfo(name: string, current: Ice.Current): PromiseLike<NodeInfo> | NodeInfo;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getNodeAdmin(name: string, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getNodeProcessorSocketCount(name: string, current: Ice.Current): PromiseLike<number> | number;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract shutdownNode(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getNodeHostname(name: string, current: Ice.Current): PromiseLike<string> | string;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllNodeNames(current: Ice.Current): PromiseLike<Ice.StringSeq> | Ice.StringSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract pingRegistry(name: string, current: Ice.Current): PromiseLike<boolean> | boolean;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRegistryInfo(name: string, current: Ice.Current): PromiseLike<RegistryInfo> | RegistryInfo;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRegistryAdmin(name: string, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract shutdownRegistry(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllRegistryNames(current: Ice.Current): PromiseLike<Ice.StringSeq> | Ice.StringSeq;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract shutdown(current: Ice.Current): PromiseLike<void> | void;
        /**
         * The IceGrid administrative interface.
         * <p class="Warning">Allowing access to this interface
         * is a security risk! Please see the IceGrid documentation
         * for further information.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getSliceChecksums(current: Ice.Current): PromiseLike<Ice.SliceChecksumDict> | Ice.SliceChecksumDict;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::Admin".
         */
        static ice_staticId(): string;
    }

    abstract class FileIteratorPrx extends Ice.ObjectPrx {
        /**
         * Read lines from the log file.
         * @param size Specifies the maximum number of bytes to be
         * received. The server will ensure that the returned message
         * doesn't exceed the given size.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        read(size: number, context?: Map<string, string>): Ice.AsyncResult<[boolean, Ice.StringSeq]>;
        /**
         * Destroy the iterator.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroy(context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): FileIteratorPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
    }

    abstract class FileIterator extends Ice.Object {
        /**
         * This interface provides access to IceGrid log file contents.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract read(size: number, current: Ice.Current): PromiseLike<[boolean, Ice.StringSeq]> | [boolean, Ice.StringSeq];
        /**
         * This interface provides access to IceGrid log file contents.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract destroy(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::FileIterator".
         */
        static ice_staticId(): string;
    }

    /**
     * Dynamic information about the state of a server.
     */
    class ServerDynamicInfo {
        constructor(id?: string, state?: ServerState, pid?: number, enabled?: boolean);
        clone(): ServerDynamicInfo;
        equals(rhs: any): boolean;
        hashCode(): number;
        id: string;
        state: ServerState;
        pid: number;
        enabled: boolean;
        static write(outs: Ice.OutputStream, value: ServerDynamicInfo): void;
        static read(ins: Ice.InputStream): ServerDynamicInfo;
    }

    /**
     * A sequence of server dynamic information structures.
     */
    type ServerDynamicInfoSeq = ServerDynamicInfo[];

    class ServerDynamicInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: ServerDynamicInfoSeq): void;
        static read(ins: Ice.InputStream): ServerDynamicInfoSeq;
    }

    /**
     * Dynamic information about the state of an adapter.
     */
    class AdapterDynamicInfo {
        constructor(id?: string, proxy?: Ice.ObjectPrx);
        clone(): AdapterDynamicInfo;
        equals(rhs: any): boolean;
        id: string;
        proxy: Ice.ObjectPrx;
        static write(outs: Ice.OutputStream, value: AdapterDynamicInfo): void;
        static read(ins: Ice.InputStream): AdapterDynamicInfo;
    }

    /**
     * A sequence of adapter dynamic information structures.
     */
    type AdapterDynamicInfoSeq = AdapterDynamicInfo[];

    class AdapterDynamicInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: AdapterDynamicInfoSeq): void;
        static read(ins: Ice.InputStream): AdapterDynamicInfoSeq;
    }

    /**
     * Dynamic information about the state of a node.
     */
    class NodeDynamicInfo {
        constructor(info?: NodeInfo, servers?: ServerDynamicInfoSeq, adapters?: AdapterDynamicInfoSeq);
        clone(): NodeDynamicInfo;
        equals(rhs: any): boolean;
        info: NodeInfo;
        servers: ServerDynamicInfoSeq;
        adapters: AdapterDynamicInfoSeq;
        static write(outs: Ice.OutputStream, value: NodeDynamicInfo): void;
        static read(ins: Ice.InputStream): NodeDynamicInfo;
    }

    abstract class RegistryObserverPrx extends Ice.ObjectPrx {
        /**
         * The <code>registryInit</code> operation is called after registration of
         * an observer to indicate the state of the registries.
         * @param registries The current state of the registries.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        registryInit(registries: RegistryInfoSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>nodeUp</code> operation is called to notify an observer that a node
         * came up.
         * @param node The node state.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        registryUp(node: RegistryInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>nodeDown</code> operation is called to notify an observer that a node
         * went down.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        registryDown(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): RegistryObserverPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<RegistryObserverPrx>;
    }

    abstract class RegistryObserver extends Ice.Object {
        /**
         * This interface allows applications to monitor changes the state
         * of the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract registryInit(registries: RegistryInfoSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor changes the state
         * of the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract registryUp(node: RegistryInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor changes the state
         * of the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract registryDown(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::RegistryObserver".
         */
        static ice_staticId(): string;
    }

    /**
     * A sequence of node dynamic information structures.
     */
    type NodeDynamicInfoSeq = NodeDynamicInfo[];

    class NodeDynamicInfoSeqHelper {
        static write(outs: Ice.OutputStream, value: NodeDynamicInfoSeq): void;
        static read(ins: Ice.InputStream): NodeDynamicInfoSeq;
    }

    abstract class NodeObserverPrx extends Ice.ObjectPrx {
        /**
         * The <code>nodeInit</code> operation indicates the current state
         * of nodes. It is called after the registration of an observer.
         * @param nodes The current state of the nodes.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        nodeInit(nodes: NodeDynamicInfoSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>nodeUp</code> operation is called to notify an observer that a node
         * came up.
         * @param node The node state.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        nodeUp(node: NodeDynamicInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>nodeDown</code> operation is called to notify an observer that a node
         * went down.
         * @param name The node name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        nodeDown(name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>updateServer</code> operation is called to notify an observer that
         * the state of a server changed.
         * @param node The node hosting the server.
         * @param updatedInfo The new server state.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateServer(node: string, updatedInfo: ServerDynamicInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>updateAdapter</code> operation is called to notify an observer that
         * the state of an adapter changed.
         * @param node The node hosting the adapter.
         * @param updatedInfo The new adapter state.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateAdapter(node: string, updatedInfo: AdapterDynamicInfo, context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): NodeObserverPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<NodeObserverPrx>;
    }

    abstract class NodeObserver extends Ice.Object {
        /**
         * The node observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * nodes.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract nodeInit(nodes: NodeDynamicInfoSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The node observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * nodes.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract nodeUp(node: NodeDynamicInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The node observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * nodes.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract nodeDown(name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The node observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * nodes.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateServer(node: string, updatedInfo: ServerDynamicInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The node observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * nodes.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateAdapter(node: string, updatedInfo: AdapterDynamicInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::NodeObserver".
         */
        static ice_staticId(): string;
    }

    abstract class ApplicationObserverPrx extends Ice.ObjectPrx {
        /**
         * <code>applicationInit</code> is called after the registration
         * of an observer to indicate the state of the registry.
         * @param serial The current serial number of the registry
         * database. This serial number allows observers to make sure that
         * their internal state is synchronized with the registry.
         * @param applications The applications currently registered with
         * the registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        applicationInit(serial: number, applications: ApplicationInfoSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>applicationAdded</code> operation is called to notify an observer
         * that an application was added.
         * @param serial The new serial number of the registry database.
         * @param desc The descriptor of the new application.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        applicationAdded(serial: number, desc: ApplicationInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>applicationRemoved</code> operation is called to notify an observer
         * that an application was removed.
         * @param serial The new serial number of the registry database.
         * @param name The name of the application that was removed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        applicationRemoved(serial: number, name: string, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>applicationUpdated</code> operation is called to notify an observer
         * that an application was updated.
         * @param serial The new serial number of the registry database.
         * @param desc The descriptor of the update.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        applicationUpdated(serial: number, desc: ApplicationUpdateInfo, context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): ApplicationObserverPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<ApplicationObserverPrx>;
    }

    abstract class ApplicationObserver extends Ice.Object {
        /**
         * The database observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * registry database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract applicationInit(serial: number, applications: ApplicationInfoSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The database observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * registry database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract applicationAdded(serial: number, desc: ApplicationInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The database observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * registry database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract applicationRemoved(serial: number, name: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * The database observer interface. Observers should implement this
         * interface to receive information about the state of the IceGrid
         * registry database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract applicationUpdated(serial: number, desc: ApplicationUpdateInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::ApplicationObserver".
         */
        static ice_staticId(): string;
    }

    abstract class AdapterObserverPrx extends Ice.ObjectPrx {
        /**
         * <code>adapterInit</code> is called after registration of
         * an observer to indicate the state of the registry.
         * @param adpts The adapters that were dynamically registered
         * with the registry (not through the deployment mechanism).
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        adapterInit(adpts: AdapterInfoSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>adapterAdded</code> operation is called to notify an observer when
         * a dynamically-registered adapter was added.
         * @param info The details of the new adapter.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        adapterAdded(info: AdapterInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The adapterUpdated operation is called to notify an observer when
         * a dynamically-registered adapter was updated.
         * @param info The details of the updated adapter.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        adapterUpdated(info: AdapterInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The adapterRemoved operation is called to notify an observer when
         * a dynamically-registered adapter was removed.
         * @param id The ID of the removed adapter.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        adapterRemoved(id: string, context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): AdapterObserverPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<AdapterObserverPrx>;
    }

    abstract class AdapterObserver extends Ice.Object {
        /**
         * This interface allows applications to monitor the state of object
         * adapters that are registered with IceGrid.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract adapterInit(adpts: AdapterInfoSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor the state of object
         * adapters that are registered with IceGrid.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract adapterAdded(info: AdapterInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor the state of object
         * adapters that are registered with IceGrid.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract adapterUpdated(info: AdapterInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor the state of object
         * adapters that are registered with IceGrid.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract adapterRemoved(id: string, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::AdapterObserver".
         */
        static ice_staticId(): string;
    }

    abstract class ObjectObserverPrx extends Ice.ObjectPrx {
        /**
         * <code>objectInit</code> is called after the registration of
         * an observer to indicate the state of the registry.
         * @param objects The objects registered with the {@link Admin}
         * interface (not through the deployment mechanism).
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        objectInit(objects: ObjectInfoSeq, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * The <code>objectAdded</code> operation is called to notify an observer when an
         * object was added to the {@link Admin} interface.
         * @param info The details of the added object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        objectAdded(info: ObjectInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * <code>objectUpdated</code> is called to notify an observer when
         * an object registered with the {@link Admin} interface was updated.
         * @param info The details of the updated object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        objectUpdated(info: ObjectInfo, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * <code>objectRemoved</code> is called to notify an observer when
         * an object registered with the {@link Admin} interface was removed.
         * @param id The identity of the removed object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        objectRemoved(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): ObjectObserverPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<ObjectObserverPrx>;
    }

    abstract class ObjectObserver extends Ice.Object {
        /**
         * This interface allows applications to monitor IceGrid well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract objectInit(objects: ObjectInfoSeq, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor IceGrid well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract objectAdded(info: ObjectInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor IceGrid well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract objectUpdated(info: ObjectInfo, current: Ice.Current): PromiseLike<void> | void;
        /**
         * This interface allows applications to monitor IceGrid well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract objectRemoved(id: Ice.Identity, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::ObjectObserver".
         */
        static ice_staticId(): string;
    }

    abstract class AdminSessionPrx extends Ice.ObjectPrx {
        /**
         * Destroy the session. This is called automatically when the router is destroyed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroy(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Keep the session alive. Clients should call this operation
         * regularly to prevent the server from reaping the session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see Registry#getSessionTimeout
         */
        keepAlive(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get the admin interface. The admin object returned by this
         * operation can only be accessed by the session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAdmin(context?: Map<string, string>): Ice.AsyncResult<AdminPrx>;
        /**
         * Get a "template" proxy for admin callback objects.
         * An Admin client uses this proxy to set the category of its callback
         * objects, and the published endpoints of the object adapter hosting
         * the admin callback objects.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAdminCallbackTemplate(context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Set the observer proxies that receive
         * notifications when the state of the registry
         * or nodes changes.
         * @param registryObs The registry observer.
         * @param nodeObs The node observer.
         * @param appObs The application observer.
         * @param adptObs The adapter observer.
         * @param objObs The object observer.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setObservers(registryObs: RegistryObserverPrx, nodeObs: NodeObserverPrx, appObs: ApplicationObserverPrx, adptObs: AdapterObserverPrx, objObs: ObjectObserverPrx, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Set the observer identities that receive
         * notifications the state of the registry
         * or nodes changes. This operation should be used by clients that
         * are using a bidirectional connection to communicate with the
         * session.
         * @param registryObs The registry observer identity.
         * @param nodeObs The node observer identity.
         * @param appObs The application observer.
         * @param adptObs The adapter observer.
         * @param objObs The object observer.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setObserversByIdentity(registryObs: Ice.Identity, nodeObs: Ice.Identity, appObs: Ice.Identity, adptObs: Ice.Identity, objObs: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Acquires an exclusive lock to start updating the registry applications.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        startUpdate(context?: Map<string, string>): Ice.AsyncResult<number>;
        /**
         * Finish updating the registry and release the exclusive lock.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        finishUpdate(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Get the name of the registry replica hosting this session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getReplicaName(context?: Map<string, string>): Ice.AsyncResult<string>;
        /**
         * Open the given server log file for reading. The file can be
         * read with the returned file iterator.
         * @param id The server id.
         * @param path The path of the log file. A log file can be opened
         * only if it's declared in the server or service deployment
         * descriptor.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openServerLog(id: string, path: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
        /**
         * Open the given server stderr file for reading. The file can be
         * read with the returned file iterator.
         * @param id The server id.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openServerStdErr(id: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
        /**
         * Open the given server stdout file for reading. The file can be
         * read with the returned file iterator.
         * @param id The server id.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openServerStdOut(id: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
        /**
         * Open the given node stderr file for reading. The file can be
         * read with the returned file iterator.
         * @param name The node name.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openNodeStdErr(name: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
        /**
         * Open the given node stdout file for reading. The file can be
         * read with the returned file iterator.
         * @param name The node name.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openNodeStdOut(name: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
        /**
         * Open the given registry stderr file for reading. The file can be
         * read with the returned file iterator.
         * @param name The registry name.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openRegistryStdErr(name: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;
        /**
         * Open the given registry stdout file for reading. The file can be
         * read with the returned file iterator.
         * @param name The registry name.
         * @param count Specifies where to start reading the file. If
         * negative, the file is read from the begining. If 0 or positive,
         * the file is read from the last <code>count</code> lines.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        openRegistryStdOut(name: string, count: number, context?: Map<string, string>): Ice.AsyncResult<FileIteratorPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): AdminSessionPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<AdminSessionPrx>;
    }

    abstract class AdminSession extends Ice.Object {
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract destroy(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract keepAlive(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract getAdmin(current: Ice.Current): PromiseLike<AdminPrx> | AdminPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract getAdminCallbackTemplate(current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract setObservers(registryObs: RegistryObserverPrx, nodeObs: NodeObserverPrx, appObs: ApplicationObserverPrx, adptObs: AdapterObserverPrx, objObs: ObjectObserverPrx, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract setObserversByIdentity(registryObs: Ice.Identity, nodeObs: Ice.Identity, appObs: Ice.Identity, adptObs: Ice.Identity, objObs: Ice.Identity, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract startUpdate(current: Ice.Current): PromiseLike<number> | number;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract finishUpdate(current: Ice.Current): PromiseLike<void> | void;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract getReplicaName(current: Ice.Current): PromiseLike<string> | string;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openServerLog(id: string, path: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openServerStdErr(id: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openServerStdOut(id: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openNodeStdErr(name: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openNodeStdOut(name: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openRegistryStdErr(name: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Used by administrative clients to view,
         * update, and receive observer updates from the IceGrid
         * registry. Admin sessions are created either via the {@link Registry}
         * object or via the registry admin <code>SessionManager</code> object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract openRegistryStdOut(name: string, count: number, current: Ice.Current): PromiseLike<FileIteratorPrx> | FileIteratorPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::AdminSession".
         */
        static ice_staticId(): string;
    }
}

export namespace IceGrid {
    /**
     * A mapping of string to string.
     */
    class StringStringDict extends Map<string, string>
    {
    }

    class StringStringDictHelper {
        static write(outs: Ice.OutputStream, value: StringStringDict): void;
        static read(ins: Ice.InputStream): StringStringDict;
    }

    /**
     * Property descriptor.
     */
    class PropertyDescriptor {
        constructor(name?: string, value?: string);
        clone(): PropertyDescriptor;
        equals(rhs: any): boolean;
        hashCode(): number;
        name: string;
        value: string;
        static write(outs: Ice.OutputStream, value: PropertyDescriptor): void;
        static read(ins: Ice.InputStream): PropertyDescriptor;
    }

    /**
     * A sequence of property descriptors.
     */
    type PropertyDescriptorSeq = PropertyDescriptor[];

    class PropertyDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: PropertyDescriptorSeq): void;
        static read(ins: Ice.InputStream): PropertyDescriptorSeq;
    }

    /**
     * A property set descriptor.
     */
    class PropertySetDescriptor {
        constructor(references?: Ice.StringSeq, properties?: PropertyDescriptorSeq);
        clone(): PropertySetDescriptor;
        equals(rhs: any): boolean;
        hashCode(): number;
        references: Ice.StringSeq;
        properties: PropertyDescriptorSeq;
        static write(outs: Ice.OutputStream, value: PropertySetDescriptor): void;
        static read(ins: Ice.InputStream): PropertySetDescriptor;
    }

    /**
     * A mapping of property set name to property set descriptor.
     */
    class PropertySetDescriptorDict extends Map<string, PropertySetDescriptor>
    {
    }

    class PropertySetDescriptorDictHelper {
        static write(outs: Ice.OutputStream, value: PropertySetDescriptorDict): void;
        static read(ins: Ice.InputStream): PropertySetDescriptorDict;
    }

    /**
     * An Ice object descriptor.
     */
    class ObjectDescriptor {
        constructor(id?: Ice.Identity, type?: string, proxyOptions?: string);
        clone(): ObjectDescriptor;
        equals(rhs: any): boolean;
        hashCode(): number;
        id: Ice.Identity;
        type: string;
        proxyOptions: string;
        static write(outs: Ice.OutputStream, value: ObjectDescriptor): void;
        static read(ins: Ice.InputStream): ObjectDescriptor;
    }

    /**
     * A sequence of object descriptors.
     */
    type ObjectDescriptorSeq = ObjectDescriptor[];

    class ObjectDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ObjectDescriptorSeq): void;
        static read(ins: Ice.InputStream): ObjectDescriptorSeq;
    }

    /**
     * An Ice object adapter descriptor.
     */
    class AdapterDescriptor {
        constructor(name?: string, description?: string, id?: string, replicaGroupId?: string, priority?: string, registerProcess?: boolean, serverLifetime?: boolean, objects?: ObjectDescriptorSeq, allocatables?: ObjectDescriptorSeq);
        clone(): AdapterDescriptor;
        equals(rhs: any): boolean;
        hashCode(): number;
        name: string;
        description: string;
        id: string;
        replicaGroupId: string;
        priority: string;
        registerProcess: boolean;
        serverLifetime: boolean;
        objects: ObjectDescriptorSeq;
        allocatables: ObjectDescriptorSeq;
        static write(outs: Ice.OutputStream, value: AdapterDescriptor): void;
        static read(ins: Ice.InputStream): AdapterDescriptor;
    }

    /**
     * A sequence of adapter descriptors.
     */
    type AdapterDescriptorSeq = AdapterDescriptor[];

    class AdapterDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: AdapterDescriptorSeq): void;
        static read(ins: Ice.InputStream): AdapterDescriptorSeq;
    }

    /**
     * A Freeze database environment descriptor.
     */
    class DbEnvDescriptor {
        constructor(name?: string, description?: string, dbHome?: string, properties?: PropertyDescriptorSeq);
        clone(): DbEnvDescriptor;
        equals(rhs: any): boolean;
        hashCode(): number;
        name: string;
        description: string;
        dbHome: string;
        properties: PropertyDescriptorSeq;
        static write(outs: Ice.OutputStream, value: DbEnvDescriptor): void;
        static read(ins: Ice.InputStream): DbEnvDescriptor;
    }

    /**
     * A sequence of database environment descriptors.
     */
    type DbEnvDescriptorSeq = DbEnvDescriptor[];

    class DbEnvDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: DbEnvDescriptorSeq): void;
        static read(ins: Ice.InputStream): DbEnvDescriptorSeq;
    }

    /**
     * A communicator descriptor.
     */
    class CommunicatorDescriptor extends Ice.Value {
        /**
         * One-shot constructor to initialize all data members.
         * @param adapters The object adapters.
         * @param propertySet The property set.
         * @param dbEnvs The database environments.
         * @param logs The path of each log file.
         * @param description A description of this descriptor.
         */
        constructor(adapters?: AdapterDescriptorSeq, propertySet?: PropertySetDescriptor, dbEnvs?: DbEnvDescriptorSeq, logs?: Ice.StringSeq, description?: string);
        /**
         * The object adapters.
         */
        adapters: AdapterDescriptorSeq;
        /**
         * The property set.
         */
        propertySet: PropertySetDescriptor;
        /**
         * The database environments.
         */
        dbEnvs: DbEnvDescriptorSeq;
        /**
         * The path of each log file.
         */
        logs: Ice.StringSeq;
        /**
         * A description of this descriptor.
         */
        description: string;
    }

    /**
     * A distribution descriptor defines an IcePatch2 server and the
     * directories to retrieve from the patch server.
     */
    class DistributionDescriptor {
        constructor(icepatch?: string, directories?: Ice.StringSeq);
        clone(): DistributionDescriptor;
        equals(rhs: any): boolean;
        hashCode(): number;
        icepatch: string;
        directories: Ice.StringSeq;
        static write(outs: Ice.OutputStream, value: DistributionDescriptor): void;
        static read(ins: Ice.InputStream): DistributionDescriptor;
    }

    /**
     * An Ice server descriptor.
     */
    class ServerDescriptor extends CommunicatorDescriptor {
        /**
         * One-shot constructor to initialize all data members.
         * @param adapters The object adapters.
         * @param propertySet The property set.
         * @param dbEnvs The database environments.
         * @param logs The path of each log file.
         * @param description A description of this descriptor.
         * @param id The server id.
         * @param exe The path of the server executable.
         * @param iceVersion The Ice version used by this server.
         * @param pwd The path to the server working directory.
         * @param options The command line options to pass to the server executable.
         * @param envs The server environment variables.
         * @param activation The server activation mode (possible values are "on-demand" or "manual").
         * @param activationTimeout The activation timeout (an integer value representing the number of seconds to wait for activation).
         * @param deactivationTimeout The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
         * @param applicationDistrib Specifies if the server depends on the application distribution.
         * @param distrib The distribution descriptor.
         * @param allocatable Specifies if the server is allocatable.
         * @param user The user account used to run the server.
         */
        constructor(adapters?: AdapterDescriptorSeq, propertySet?: PropertySetDescriptor, dbEnvs?: DbEnvDescriptorSeq, logs?: Ice.StringSeq, description?: string, id?: string, exe?: string, iceVersion?: string, pwd?: string, options?: Ice.StringSeq, envs?: Ice.StringSeq, activation?: string, activationTimeout?: string, deactivationTimeout?: string, applicationDistrib?: boolean, distrib?: DistributionDescriptor, allocatable?: boolean, user?: string);
        /**
         * The server id.
         */
        id: string;
        /**
         * The path of the server executable.
         */
        exe: string;
        /**
         * The Ice version used by this server. This is only required if
         * backward compatibility with servers using old Ice versions is
         * needed (otherwise the registry will assume the server is using
         * the same Ice version).
         * For example "3.1.1", "3.2", "3.3.0".
         */
        iceVersion: string;
        /**
         * The path to the server working directory.
         */
        pwd: string;
        /**
         * The command line options to pass to the server executable.
         */
        options: Ice.StringSeq;
        /**
         * The server environment variables.
         */
        envs: Ice.StringSeq;
        /**
         * The server activation mode (possible values are "on-demand" or
         * "manual").
         */
        activation: string;
        /**
         * The activation timeout (an integer value representing the
         * number of seconds to wait for activation).
         */
        activationTimeout: string;
        /**
         * The deactivation timeout (an integer value representing the
         * number of seconds to wait for deactivation).
         */
        deactivationTimeout: string;
        /**
         * Specifies if the server depends on the application
         * distribution.
         */
        applicationDistrib: boolean;
        /**
         * The distribution descriptor.
         */
        distrib: DistributionDescriptor;
        /**
         * Specifies if the server is allocatable.
         */
        allocatable: boolean;
        /**
         * The user account used to run the server.
         */
        user: string;
    }

    /**
     * A sequence of server descriptors.
     */
    type ServerDescriptorSeq = IceGrid.ServerDescriptor[];

    class ServerDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ServerDescriptorSeq): void;
        static read(ins: Ice.InputStream): ServerDescriptorSeq;
    }

    /**
     * An IceBox service descriptor.
     */
    class ServiceDescriptor extends CommunicatorDescriptor {
        /**
         * One-shot constructor to initialize all data members.
         * @param adapters The object adapters.
         * @param propertySet The property set.
         * @param dbEnvs The database environments.
         * @param logs The path of each log file.
         * @param description A description of this descriptor.
         * @param name The service name.
         * @param entry The entry point of the IceBox service.
         */
        constructor(adapters?: AdapterDescriptorSeq, propertySet?: PropertySetDescriptor, dbEnvs?: DbEnvDescriptorSeq, logs?: Ice.StringSeq, description?: string, name?: string, entry?: string);
        /**
         * The service name.
         */
        name: string;
        /**
         * The entry point of the IceBox service.
         */
        entry: string;
    }

    /**
     * A sequence of service descriptors.
     */
    type ServiceDescriptorSeq = IceGrid.ServiceDescriptor[];

    class ServiceDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ServiceDescriptorSeq): void;
        static read(ins: Ice.InputStream): ServiceDescriptorSeq;
    }

    /**
     * A server template instance descriptor.
     */
    class ServerInstanceDescriptor {
        constructor(template?: string, parameterValues?: StringStringDict, propertySet?: PropertySetDescriptor, servicePropertySets?: PropertySetDescriptorDict);
        clone(): ServerInstanceDescriptor;
        equals(rhs: any): boolean;
        template: string;
        parameterValues: StringStringDict;
        propertySet: PropertySetDescriptor;
        servicePropertySets: PropertySetDescriptorDict;
        static write(outs: Ice.OutputStream, value: ServerInstanceDescriptor): void;
        static read(ins: Ice.InputStream): ServerInstanceDescriptor;
    }

    /**
     * A sequence of server instance descriptors.
     */
    type ServerInstanceDescriptorSeq = ServerInstanceDescriptor[];

    class ServerInstanceDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ServerInstanceDescriptorSeq): void;
        static read(ins: Ice.InputStream): ServerInstanceDescriptorSeq;
    }

    /**
     * A template descriptor for server or service templates.
     */
    class TemplateDescriptor {
        constructor(descriptor?: IceGrid.CommunicatorDescriptor, parameters?: Ice.StringSeq, parameterDefaults?: StringStringDict);
        clone(): TemplateDescriptor;
        equals(rhs: any): boolean;
        descriptor: IceGrid.CommunicatorDescriptor;
        parameters: Ice.StringSeq;
        parameterDefaults: StringStringDict;
        static write(outs: Ice.OutputStream, value: TemplateDescriptor): void;
        static read(ins: Ice.InputStream): TemplateDescriptor;
    }

    /**
     * A mapping of template identifier to template descriptor.
     */
    class TemplateDescriptorDict extends Map<string, TemplateDescriptor>
    {
    }

    class TemplateDescriptorDictHelper {
        static write(outs: Ice.OutputStream, value: TemplateDescriptorDict): void;
        static read(ins: Ice.InputStream): TemplateDescriptorDict;
    }

    /**
     * A service template instance descriptor.
     */
    class ServiceInstanceDescriptor {
        constructor(template?: string, parameterValues?: StringStringDict, descriptor?: IceGrid.ServiceDescriptor, propertySet?: PropertySetDescriptor);
        clone(): ServiceInstanceDescriptor;
        equals(rhs: any): boolean;
        template: string;
        parameterValues: StringStringDict;
        descriptor: IceGrid.ServiceDescriptor;
        propertySet: PropertySetDescriptor;
        static write(outs: Ice.OutputStream, value: ServiceInstanceDescriptor): void;
        static read(ins: Ice.InputStream): ServiceInstanceDescriptor;
    }

    /**
     * A sequence of service instance descriptors.
     */
    type ServiceInstanceDescriptorSeq = ServiceInstanceDescriptor[];

    class ServiceInstanceDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ServiceInstanceDescriptorSeq): void;
        static read(ins: Ice.InputStream): ServiceInstanceDescriptorSeq;
    }

    /**
     * An IceBox server descriptor.
     */
    class IceBoxDescriptor extends ServerDescriptor {
        /**
         * One-shot constructor to initialize all data members.
         * @param adapters The object adapters.
         * @param propertySet The property set.
         * @param dbEnvs The database environments.
         * @param logs The path of each log file.
         * @param description A description of this descriptor.
         * @param id The server id.
         * @param exe The path of the server executable.
         * @param iceVersion The Ice version used by this server.
         * @param pwd The path to the server working directory.
         * @param options The command line options to pass to the server executable.
         * @param envs The server environment variables.
         * @param activation The server activation mode (possible values are "on-demand" or "manual").
         * @param activationTimeout The activation timeout (an integer value representing the number of seconds to wait for activation).
         * @param deactivationTimeout The deactivation timeout (an integer value representing the number of seconds to wait for deactivation).
         * @param applicationDistrib Specifies if the server depends on the application distribution.
         * @param distrib The distribution descriptor.
         * @param allocatable Specifies if the server is allocatable.
         * @param user The user account used to run the server.
         * @param services The service instances.
         */
        constructor(adapters?: AdapterDescriptorSeq, propertySet?: PropertySetDescriptor, dbEnvs?: DbEnvDescriptorSeq, logs?: Ice.StringSeq, description?: string, id?: string, exe?: string, iceVersion?: string, pwd?: string, options?: Ice.StringSeq, envs?: Ice.StringSeq, activation?: string, activationTimeout?: string, deactivationTimeout?: string, applicationDistrib?: boolean, distrib?: DistributionDescriptor, allocatable?: boolean, user?: string, services?: ServiceInstanceDescriptorSeq);
        /**
         * The service instances.
         */
        services: ServiceInstanceDescriptorSeq;
    }

    /**
     * A node descriptor.
     */
    class NodeDescriptor {
        constructor(variables?: StringStringDict, serverInstances?: ServerInstanceDescriptorSeq, servers?: ServerDescriptorSeq, loadFactor?: string, description?: string, propertySets?: PropertySetDescriptorDict);
        clone(): NodeDescriptor;
        equals(rhs: any): boolean;
        variables: StringStringDict;
        serverInstances: ServerInstanceDescriptorSeq;
        servers: ServerDescriptorSeq;
        loadFactor: string;
        description: string;
        propertySets: PropertySetDescriptorDict;
        static write(outs: Ice.OutputStream, value: NodeDescriptor): void;
        static read(ins: Ice.InputStream): NodeDescriptor;
    }

    /**
     * Mapping of node name to node descriptor.
     */
    class NodeDescriptorDict extends Map<string, NodeDescriptor>
    {
    }

    class NodeDescriptorDictHelper {
        static write(outs: Ice.OutputStream, value: NodeDescriptorDict): void;
        static read(ins: Ice.InputStream): NodeDescriptorDict;
    }

    /**
     * A base class for load balancing policies.
     */
    class LoadBalancingPolicy extends Ice.Value {
        /**
         * One-shot constructor to initialize all data members.
         * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
         */
        constructor(nReplicas?: string);
        /**
         * The number of replicas that will be used to gather the
         * endpoints of a replica group.
         */
        nReplicas: string;
    }

    /**
     * Random load balancing policy.
     */
    class RandomLoadBalancingPolicy extends LoadBalancingPolicy {
        /**
         * One-shot constructor to initialize all data members.
         * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
         */
        constructor(nReplicas?: string);
    }

    /**
     * Ordered load balancing policy.
     */
    class OrderedLoadBalancingPolicy extends LoadBalancingPolicy {
        /**
         * One-shot constructor to initialize all data members.
         * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
         */
        constructor(nReplicas?: string);
    }

    /**
     * Round robin load balancing policy.
     */
    class RoundRobinLoadBalancingPolicy extends LoadBalancingPolicy {
        /**
         * One-shot constructor to initialize all data members.
         * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
         */
        constructor(nReplicas?: string);
    }

    /**
     * Adaptive load balancing policy.
     */
    class AdaptiveLoadBalancingPolicy extends LoadBalancingPolicy {
        /**
         * One-shot constructor to initialize all data members.
         * @param nReplicas The number of replicas that will be used to gather the endpoints of a replica group.
         * @param loadSample The load sample to use for the load balancing.
         */
        constructor(nReplicas?: string, loadSample?: string);
        /**
         * The load sample to use for the load balancing. The allowed
         * values for this attribute are "1", "5" and "15", representing
         * respectively the load average over the past minute, the past 5
         * minutes and the past 15 minutes.
         */
        loadSample: string;
    }

    /**
     * A replica group descriptor.
     */
    class ReplicaGroupDescriptor {
        constructor(id?: string, loadBalancing?: IceGrid.LoadBalancingPolicy, proxyOptions?: string, objects?: ObjectDescriptorSeq, description?: string, filter?: string);
        clone(): ReplicaGroupDescriptor;
        equals(rhs: any): boolean;
        id: string;
        loadBalancing: IceGrid.LoadBalancingPolicy;
        proxyOptions: string;
        objects: ObjectDescriptorSeq;
        description: string;
        filter: string;
        static write(outs: Ice.OutputStream, value: ReplicaGroupDescriptor): void;
        static read(ins: Ice.InputStream): ReplicaGroupDescriptor;
    }

    /**
     * A sequence of replica groups.
     */
    type ReplicaGroupDescriptorSeq = ReplicaGroupDescriptor[];

    class ReplicaGroupDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ReplicaGroupDescriptorSeq): void;
        static read(ins: Ice.InputStream): ReplicaGroupDescriptorSeq;
    }

    /**
     * An application descriptor.
     */
    class ApplicationDescriptor {
        constructor(name?: string, variables?: StringStringDict, replicaGroups?: ReplicaGroupDescriptorSeq, serverTemplates?: TemplateDescriptorDict, serviceTemplates?: TemplateDescriptorDict, nodes?: NodeDescriptorDict, distrib?: DistributionDescriptor, description?: string, propertySets?: PropertySetDescriptorDict);
        clone(): ApplicationDescriptor;
        equals(rhs: any): boolean;
        name: string;
        variables: StringStringDict;
        replicaGroups: ReplicaGroupDescriptorSeq;
        serverTemplates: TemplateDescriptorDict;
        serviceTemplates: TemplateDescriptorDict;
        nodes: NodeDescriptorDict;
        distrib: DistributionDescriptor;
        description: string;
        propertySets: PropertySetDescriptorDict;
        static write(outs: Ice.OutputStream, value: ApplicationDescriptor): void;
        static read(ins: Ice.InputStream): ApplicationDescriptor;
    }

    /**
     * A sequence of application descriptors.
     */
    type ApplicationDescriptorSeq = ApplicationDescriptor[];

    class ApplicationDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: ApplicationDescriptorSeq): void;
        static read(ins: Ice.InputStream): ApplicationDescriptorSeq;
    }

    /**
     * A "boxed" string.
     */
    class BoxedString extends Ice.Value {
        /**
         * One-shot constructor to initialize all data members.
         * @param value The value of the boxed string.
         */
        constructor(value?: string);
        /**
         * The value of the boxed string.
         */
        value: string;
    }

    /**
     * A node update descriptor to describe the updates to apply to a
     * node of a deployed application.
     */
    class NodeUpdateDescriptor {
        constructor(name?: string, description?: IceGrid.BoxedString, variables?: StringStringDict, removeVariables?: Ice.StringSeq, propertySets?: PropertySetDescriptorDict, removePropertySets?: Ice.StringSeq, serverInstances?: ServerInstanceDescriptorSeq, servers?: ServerDescriptorSeq, removeServers?: Ice.StringSeq, loadFactor?: IceGrid.BoxedString);
        clone(): NodeUpdateDescriptor;
        equals(rhs: any): boolean;
        name: string;
        description: IceGrid.BoxedString;
        variables: StringStringDict;
        removeVariables: Ice.StringSeq;
        propertySets: PropertySetDescriptorDict;
        removePropertySets: Ice.StringSeq;
        serverInstances: ServerInstanceDescriptorSeq;
        servers: ServerDescriptorSeq;
        removeServers: Ice.StringSeq;
        loadFactor: IceGrid.BoxedString;
        static write(outs: Ice.OutputStream, value: NodeUpdateDescriptor): void;
        static read(ins: Ice.InputStream): NodeUpdateDescriptor;
    }

    /**
     * A sequence of node update descriptors.
     */
    type NodeUpdateDescriptorSeq = NodeUpdateDescriptor[];

    class NodeUpdateDescriptorSeqHelper {
        static write(outs: Ice.OutputStream, value: NodeUpdateDescriptorSeq): void;
        static read(ins: Ice.InputStream): NodeUpdateDescriptorSeq;
    }

    /**
     * A "boxed" distribution descriptor.
     */
    class BoxedDistributionDescriptor extends Ice.Value {
        /**
         * One-shot constructor to initialize all data members.
         * @param value The value of the boxed distribution descriptor.
         */
        constructor(value?: DistributionDescriptor);
        /**
         * The value of the boxed distribution descriptor.
         */
        value: DistributionDescriptor;
    }

    /**
     * An application update descriptor to describe the updates to apply
     * to a deployed application.
     */
    class ApplicationUpdateDescriptor {
        constructor(name?: string, description?: IceGrid.BoxedString, distrib?: IceGrid.BoxedDistributionDescriptor, variables?: StringStringDict, removeVariables?: Ice.StringSeq, propertySets?: PropertySetDescriptorDict, removePropertySets?: Ice.StringSeq, replicaGroups?: ReplicaGroupDescriptorSeq, removeReplicaGroups?: Ice.StringSeq, serverTemplates?: TemplateDescriptorDict, removeServerTemplates?: Ice.StringSeq, serviceTemplates?: TemplateDescriptorDict, removeServiceTemplates?: Ice.StringSeq, nodes?: NodeUpdateDescriptorSeq, removeNodes?: Ice.StringSeq);
        clone(): ApplicationUpdateDescriptor;
        equals(rhs: any): boolean;
        name: string;
        description: IceGrid.BoxedString;
        distrib: IceGrid.BoxedDistributionDescriptor;
        variables: StringStringDict;
        removeVariables: Ice.StringSeq;
        propertySets: PropertySetDescriptorDict;
        removePropertySets: Ice.StringSeq;
        replicaGroups: ReplicaGroupDescriptorSeq;
        removeReplicaGroups: Ice.StringSeq;
        serverTemplates: TemplateDescriptorDict;
        removeServerTemplates: Ice.StringSeq;
        serviceTemplates: TemplateDescriptorDict;
        removeServiceTemplates: Ice.StringSeq;
        nodes: NodeUpdateDescriptorSeq;
        removeNodes: Ice.StringSeq;
        static write(outs: Ice.OutputStream, value: ApplicationUpdateDescriptor): void;
        static read(ins: Ice.InputStream): ApplicationUpdateDescriptor;
    }
}

export namespace IceGrid {
    /**
     * This exception is raised if an application does not exist.
     */
    class ApplicationNotExistException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the application.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * This exception is raised if a server does not exist.
     */
    class ServerNotExistException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identifier of the server.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: string, ice_cause?: string | Error);
        id: string;
    }

    /**
     * This exception is raised if a server failed to start.
     */
    class ServerStartException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identifier of the server.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: string, reason?: string, ice_cause?: string | Error);
        id: string;
        reason: string;
    }

    /**
     * This exception is raised if a server failed to stop.
     */
    class ServerStopException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identifier of the server.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: string, reason?: string, ice_cause?: string | Error);
        id: string;
        reason: string;
    }

    /**
     * This exception is raised if an adapter does not exist.
     */
    class AdapterNotExistException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The id of the object adapter.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: string, ice_cause?: string | Error);
        id: string;
    }

    /**
     * This exception is raised if an object already exists.
     */
    class ObjectExistsException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the object.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Ice.Identity, ice_cause?: string | Error);
        id: Ice.Identity;
    }

    /**
     * This exception is raised if an object is not registered.
     */
    class ObjectNotRegisteredException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the object.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Ice.Identity, ice_cause?: string | Error);
        id: Ice.Identity;
    }

    /**
     * This exception is raised if a node does not exist.
     */
    class NodeNotExistException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The node name.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * This exception is raised if a registry does not exist.
     */
    class RegistryNotExistException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The registry name.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, ice_cause?: string | Error);
        name: string;
    }

    /**
     * An exception for deployment errors.
     */
    class DeploymentException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception is raised if a node could not be reached.
     */
    class NodeUnreachableException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the node that is not reachable.
         * @param reason The reason why the node couldn't be reached.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, reason?: string, ice_cause?: string | Error);
        name: string;
        reason: string;
    }

    /**
     * This exception is raised if a server could not be reached.
     */
    class ServerUnreachableException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The id of the server that is not reachable.
         * @param reason The reason why the server couldn't be reached.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, reason?: string, ice_cause?: string | Error);
        name: string;
        reason: string;
    }

    /**
     * This exception is raised if a registry could not be reached.
     */
    class RegistryUnreachableException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param name The name of the registry that is not reachable.
         * @param reason The reason why the registry couldn't be reached.
         * @param ice_cause The error that cause this exception.
         */
        constructor(name?: string, reason?: string, ice_cause?: string | Error);
        name: string;
        reason: string;
    }

    /**
     * This exception is raised if an unknown signal was sent to
     * to a server.
     */
    class BadSignalException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The details of the unknown signal.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception is raised if a patch failed.
     */
    class PatchException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reasons The reasons why the patch failed.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reasons?: Ice.StringSeq, ice_cause?: string | Error);
        reasons: Ice.StringSeq;
    }

    /**
     * This exception is raised if a registry lock wasn't
     * acquired or is already held by a session.
     */
    class AccessDeniedException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param lockUserId The id of the user holding the lock (if any).
         * @param ice_cause The error that cause this exception.
         */
        constructor(lockUserId?: string, ice_cause?: string | Error);
        lockUserId: string;
    }

    /**
     * This exception is raised if the allocation of an object failed.
     */
    class AllocationException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason why the object couldn't be allocated.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception is raised if the request to allocate an object times
     * out.
     */
    class AllocationTimeoutException extends AllocationException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason why the object couldn't be allocated.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
    }

    /**
     * This exception is raised if a client is denied the ability to create
     * a session with IceGrid.
     */
    class PermissionDeniedException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason why permission was denied.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    /**
     * This exception is raised if an observer is already registered with
     * the registry.
     * @see AdminSession#setObservers
     * @see AdminSession#setObserversByIdentity
     */
    class ObserverAlreadyRegisteredException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param id The identity of the observer.
         * @param ice_cause The error that cause this exception.
         */
        constructor(id?: Ice.Identity, ice_cause?: string | Error);
        id: Ice.Identity;
    }

    /**
     * This exception is raised if a file is not available.
     * @see AdminSession#openServerStdOut
     * @see AdminSession#openServerStdErr
     * @see AdminSession#openNodeStdOut
     * @see AdminSession#openNodeStdErr
     * @see AdminSession#openRegistryStdOut
     * @see AdminSession#openRegistryStdErr
     */
    class FileNotAvailableException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }
}

export namespace IceGrid {
    /**
     * This exception is raised if an error occurs during parsing.
     */
    class ParseException extends Ice.UserException {
        /**
         * One-shot constructor to initialize all data members.
         * @param reason The reason for the failure.
         * @param ice_cause The error that cause this exception.
         */
        constructor(reason?: string, ice_cause?: string | Error);
        reason: string;
    }

    abstract class FileParserPrx extends Ice.ObjectPrx {
        /**
         * Parse a file.
         * @param xmlFile Full pathname to the file.
         * @param adminProxy An Admin proxy, used only to retrieve default
         * templates when needed. May be null.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        parse(xmlFile: string, adminProxy: AdminPrx, context?: Map<string, string>): Ice.AsyncResult<ApplicationDescriptor>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): FileParserPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<FileParserPrx>;
    }

    abstract class FileParser extends Ice.Object {
        /**
         * <code>icegridadmin</code> provides a {@link FileParser}
         * object to transform XML files into {@link ApplicationDescriptor}
         * objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract parse(xmlFile: string, adminProxy: AdminPrx, current: Ice.Current): PromiseLike<ApplicationDescriptor> | ApplicationDescriptor;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::FileParser".
         */
        static ice_staticId(): string;
    }
}

export namespace IceGrid {
    /**
     * Determines which load sampling interval to use.
     */
    class LoadSample {
        /**
         * Sample every minute.
         */
        static readonly LoadSample1: LoadSample;
        /**
         * Sample every five minutes.
         */
        static readonly LoadSample5: LoadSample;
        /**
         * Sample every fifteen minutes.
         */
        static readonly LoadSample15: LoadSample;

        static valueOf(value: number): LoadSample;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    abstract class QueryPrx extends Ice.ObjectPrx {
        /**
         * Find a well-known object by identity.
         * @param id The identity.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findObjectById(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Find a well-known object by type. If there are several objects
         * registered for the given type, the object is randomly
         * selected.
         * @param type The object type.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findObjectByType(type: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Find a well-known object by type on the least-loaded node. If
         * the registry does not know which node hosts the object
         * (for example, because the object was registered with a direct proxy), the
         * registry assumes the object is hosted on a node that has a load
         * average of 1.0.
         * @param type The object type.
         * @param sample The sampling interval.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findObjectByTypeOnLeastLoadedNode(type: string, sample: LoadSample, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Find all the well-known objects with the given type.
         * @param type The object type.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findAllObjectsByType(type: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectProxySeq>;
        /**
         * Find all the object replicas associated with the given
         * proxy. If the given proxy is not an indirect proxy from a
         * replica group, an empty sequence is returned.
         * @param proxy The object proxy.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findAllReplicas(proxy: Ice.ObjectPrx, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectProxySeq>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): QueryPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<QueryPrx>;
    }

    abstract class Query extends Ice.Object {
        /**
         * The IceGrid query interface. This interface is accessible to
         * Ice clients who wish to look up well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findObjectById(id: Ice.Identity, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid query interface. This interface is accessible to
         * Ice clients who wish to look up well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findObjectByType(type: string, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid query interface. This interface is accessible to
         * Ice clients who wish to look up well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findObjectByTypeOnLeastLoadedNode(type: string, sample: LoadSample, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid query interface. This interface is accessible to
         * Ice clients who wish to look up well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findAllObjectsByType(type: string, current: Ice.Current): PromiseLike<Ice.ObjectProxySeq> | Ice.ObjectProxySeq;
        /**
         * The IceGrid query interface. This interface is accessible to
         * Ice clients who wish to look up well-known objects.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract findAllReplicas(proxy: Ice.ObjectPrx, current: Ice.Current): PromiseLike<Ice.ObjectProxySeq> | Ice.ObjectProxySeq;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::Query".
         */
        static ice_staticId(): string;
    }

    abstract class RegistryPrx extends Ice.ObjectPrx {
        /**
         * Create a client session.
         * @param userId The user id.
         * @param password The password for the given user id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        createSession(userId: string, password: string, context?: Map<string, string>): Ice.AsyncResult<SessionPrx>;
        /**
         * Create an administrative session.
         * @param userId The user id.
         * @param password The password for the given user id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        createAdminSession(userId: string, password: string, context?: Map<string, string>): Ice.AsyncResult<AdminSessionPrx>;
        /**
         * Create a client session from a secure connection.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        createSessionFromSecureConnection(context?: Map<string, string>): Ice.AsyncResult<SessionPrx>;
        /**
         * Create an administrative session from a secure connection.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        createAdminSessionFromSecureConnection(context?: Map<string, string>): Ice.AsyncResult<AdminSessionPrx>;
        /**
         * Get the session timeout. If a client or administrative client
         * doesn't call the session keepAlive method in the time interval
         * defined by this timeout, IceGrid might reap the session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see Session#keepAlive
         * @see AdminSession#keepAlive
         */
        getSessionTimeout(context?: Map<string, string>): Ice.AsyncResult<number>;
        /**
         * Get the value of the ACM timeout. Clients supporting ACM
         * connection heartbeats can enable them instead of explicitly
         * sending keep alives requests.
         *
         * NOTE: This method is only available since Ice 3.6.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getACMTimeout(context?: Map<string, string>): Ice.AsyncResult<number>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): RegistryPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<RegistryPrx>;
    }

    abstract class Registry extends Ice.Object {
        /**
         * The IceGrid registry allows clients create sessions
         * directly with the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see AdminSession
         */
        abstract createSession(userId: string, password: string, current: Ice.Current): PromiseLike<SessionPrx> | SessionPrx;
        /**
         * The IceGrid registry allows clients create sessions
         * directly with the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see AdminSession
         */
        abstract createAdminSession(userId: string, password: string, current: Ice.Current): PromiseLike<AdminSessionPrx> | AdminSessionPrx;
        /**
         * The IceGrid registry allows clients create sessions
         * directly with the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see AdminSession
         */
        abstract createSessionFromSecureConnection(current: Ice.Current): PromiseLike<SessionPrx> | SessionPrx;
        /**
         * The IceGrid registry allows clients create sessions
         * directly with the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see AdminSession
         */
        abstract createAdminSessionFromSecureConnection(current: Ice.Current): PromiseLike<AdminSessionPrx> | AdminSessionPrx;
        /**
         * The IceGrid registry allows clients create sessions
         * directly with the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see AdminSession
         */
        abstract getSessionTimeout(current: Ice.Current): PromiseLike<number> | number;
        /**
         * The IceGrid registry allows clients create sessions
         * directly with the registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Session
         * @see AdminSession
         */
        abstract getACMTimeout(current: Ice.Current): PromiseLike<number> | number;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::Registry".
         */
        static ice_staticId(): string;
    }

    abstract class LocatorPrx extends Ice.ObjectPrx {
        /**
         * Find an object by identity and return a proxy that contains
         * the adapter ID or endpoints which can be used to access the
         * object.
         * @param id The identity.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findObjectById(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Find an adapter by id and return a proxy that contains
         * its endpoints.
         * @param id The adapter id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        findAdapterById(id: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Get the locator registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegistry(context?: Map<string, string>): Ice.AsyncResult<Ice.LocatorRegistryPrx>;
        /**
         * Get the proxy of the registry object hosted by this IceGrid
         * registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLocalRegistry(context?: Map<string, string>): Ice.AsyncResult<RegistryPrx>;
        /**
         * Get the proxy of the query object hosted by this IceGrid
         * registry.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLocalQuery(context?: Map<string, string>): Ice.AsyncResult<QueryPrx>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): LocatorPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<LocatorPrx>;
    }

    abstract class Locator extends Ice.Object {
        /**
         * The IceGrid locator interface provides access to the {@link Query}
         * and {@link Registry} object of the IceGrid registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Query
         * @see Registry
         */
        abstract findObjectById(id: Ice.Identity, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid locator interface provides access to the {@link Query}
         * and {@link Registry} object of the IceGrid registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Query
         * @see Registry
         */
        abstract findAdapterById(id: string, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * The IceGrid locator interface provides access to the {@link Query}
         * and {@link Registry} object of the IceGrid registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Query
         * @see Registry
         */
        abstract getRegistry(current: Ice.Current): PromiseLike<Ice.LocatorRegistryPrx> | Ice.LocatorRegistryPrx;
        /**
         * The IceGrid locator interface provides access to the {@link Query}
         * and {@link Registry} object of the IceGrid registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Query
         * @see Registry
         */
        abstract getLocalRegistry(current: Ice.Current): PromiseLike<RegistryPrx> | RegistryPrx;
        /**
         * The IceGrid locator interface provides access to the {@link Query}
         * and {@link Registry} object of the IceGrid registry.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Query
         * @see Registry
         */
        abstract getLocalQuery(current: Ice.Current): PromiseLike<QueryPrx> | QueryPrx;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::Locator".
         */
        static ice_staticId(): string;
    }
}

export namespace IceGrid {
    abstract class SessionPrx extends Ice.ObjectPrx {
        /**
         * Destroy the session. This is called automatically when the router is destroyed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        destroy(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Keep the session alive. Clients should call this operation
         * regularly to prevent the server from reaping the session.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see Registry#getSessionTimeout
         */
        keepAlive(context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Allocate an object. Depending on the allocation timeout, this
         * operation might hang until the object is available or until the
         * timeout is reached.
         * @param id The identity of the object to allocate.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see #setAllocationTimeout
         * @see #releaseObject
         */
        allocateObjectById(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Allocate an object with the given type. Depending on the
         * allocation timeout, this operation can block until an object
         * becomes available or until the timeout is reached.
         * @param type The type of the object.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see #setAllocationTimeout
         * @see #releaseObject
         */
        allocateObjectByType(type: string, context?: Map<string, string>): Ice.AsyncResult<Ice.ObjectPrx>;
        /**
         * Release an object that was allocated using <code>allocateObjectById</code> or
         * <code>allocateObjectByType</code>.
         * @param id The identity of the object to release.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        releaseObject(id: Ice.Identity, context?: Map<string, string>): Ice.AsyncResult<void>;
        /**
         * Set the allocation timeout. If no objects are available for an
         * allocation request, a call to <code>allocateObjectById</code> or
         * <code>allocateObjectByType</code> will block for the duration of this
         * timeout.
         * @param timeout The timeout in milliseconds.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setAllocationTimeout(timeout: number, context?: Map<string, string>): Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): SessionPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<SessionPrx>;
    }

    abstract class Session extends Ice.Object {
        /**
         * A session object is used by IceGrid clients to allocate and
         * release objects. Client sessions are created either via the
         * {@link Registry} object or via the registry client <code>SessionManager</code>
         * object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract destroy(current: Ice.Current): PromiseLike<void> | void;
        /**
         * A session object is used by IceGrid clients to allocate and
         * release objects. Client sessions are created either via the
         * {@link Registry} object or via the registry client <code>SessionManager</code>
         * object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract keepAlive(current: Ice.Current): PromiseLike<void> | void;
        /**
         * A session object is used by IceGrid clients to allocate and
         * release objects. Client sessions are created either via the
         * {@link Registry} object or via the registry client <code>SessionManager</code>
         * object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract allocateObjectById(id: Ice.Identity, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * A session object is used by IceGrid clients to allocate and
         * release objects. Client sessions are created either via the
         * {@link Registry} object or via the registry client <code>SessionManager</code>
         * object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract allocateObjectByType(type: string, current: Ice.Current): PromiseLike<Ice.ObjectPrx> | Ice.ObjectPrx;
        /**
         * A session object is used by IceGrid clients to allocate and
         * release objects. Client sessions are created either via the
         * {@link Registry} object or via the registry client <code>SessionManager</code>
         * object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract releaseObject(id: Ice.Identity, current: Ice.Current): PromiseLike<void> | void;
        /**
         * A session object is used by IceGrid clients to allocate and
         * release objects. Client sessions are created either via the
         * {@link Registry} object or via the registry client <code>SessionManager</code>
         * object.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see Registry
         */
        abstract setAllocationTimeout(timeout: number, current: Ice.Current): PromiseLike<void> | void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::Session".
         */
        static ice_staticId(): string;
    }
}

export namespace IceGrid {
    /**
     * This exception is raised if a user account for a given session
     * identifier can't be found.
     */
    class UserAccountNotFoundException extends Ice.UserException {
    }

    abstract class UserAccountMapperPrx extends Ice.ObjectPrx {
        /**
         * Get the name of the user account for the given user. This is
         * used by IceGrid nodes to figure out the user account to use
         * to run servers.
         * @param user The value of the server descriptor's <code>user</code>
         * attribute. If this attribute is not defined, and the server's
         * activation mode is <code>session</code>, the default value of
         * <code>user</code> is the session identifier.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getUserAccount(user: string, context?: Map<string, string>): Ice.AsyncResult<string>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: Ice.ObjectPrx, facet?: string): UserAccountMapperPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: Ice.ObjectPrx, facet?: string, contex?: Map<string, string>): Ice.AsyncResult<UserAccountMapperPrx>;
    }

    abstract class UserAccountMapper extends Ice.Object {
        /**
         * A user account mapper object is used by IceGrid nodes to map
         * session identifiers to user accounts.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getUserAccount(user: string, current: Ice.Current): PromiseLike<string> | string;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::IceGrid::UserAccountMapper".
         */
        static ice_staticId(): string;
    }
}

export namespace IceGrid { }

export namespace Ice {

    export class Address {
        constructor(host: string, port: number);

        host: string;
        port: number;
    }

    export class ArrayUtil {
        static clone<T>(arr: T[]): T[];
        static equals(lhs: any[] | Uint8Array, rhs: any[] | Uint8Array, valuesEqual?: (v1: any, v2: any) => boolean): boolean;
        static shuffle(arr: any[]): void;
    }

    export class AsyncResult<T> extends AsyncResultBase<T>
    {
        constructor(communicator: Communicator, operation: string, connection: Connection, proxy: ObjectPrx, adapter: ObjectAdapter,
            completed: (result: AsyncResult<T>) => void);
        cancel(): void;
        isCompleted(): boolean;
        isSent(): boolean;
        throwLocalException(): void;
        sentSynchronously(): boolean;
    }

    export class AsyncResultBase<T> extends Promise<T>
    {
        constructor(communicator: Communicator, op: string, connection: Connection, proxy: ObjectPrx, adapter: ObjectAdapter);
        readonly communicator: Communicator;
        readonly connection: Connection;
        readonly proxy: ObjectPrx;
        readonly adapter: ObjectAdapter;
        readonly operation: string;
    }

    export class Debug {
        static assert(): void;
    }

    /**
     * Base class for all Ice exceptions.
     */
    export abstract class Exception extends Error {
        /**
         * Returns the name of this exception.
         *
         * @return The name of this exception.
         *
         * @deprecated ice_name() is deprecated, use ice_id() instead.
         **/
        ice_name(): string;

        /**
         * Returns the type id of this exception.
         *
         * @return The type id of this exception.
         **/
        ice_id(): string;

        /**
         * Returns a string representation of this exception.
         *
         * @return A string representation of this exception.
         **/
        toString(): string;

        ice_cause: string | Error;
    }

    /**
     * Base class for all Ice run-time exceptions.
     */
    export abstract class LocalException extends Exception { }

    /**
     * Base class for all Ice user exceptions.
     */
    export abstract class UserException extends Exception {
        /**
         * Obtains the sliced data associated with this instance.
         * @return The sliced data if the exception has a preserved-slice base class and has been sliced during
         * unmarshaling of the exception, nil otherwise.
         */
        ice_getSlicedData(): SlicedData;

        /**
         * Obtains the Slice type ID of this exception.
         * @return The fully-scoped type ID.
         */
        static ice_staticId(): string;
    }

    export class FormatType {
        static readonly DefaultFormat: FormatType;
        static readonly CompactFormat: FormatType;
        static readonly SlicedFormat: FormatType;

        static valueOf(value: number): FormatType;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    export type HashMapKey = number | string | boolean |
    {
        equals(other: any): boolean;
        hashCode(): number
    };

    export class HashMap<Key extends HashMapKey, Value>
    {
        constructor();
        constructor(other: HashMap<Key, Value>);
        constructor(keyComparator: (k1: Key, k2: Key) => boolean,
            valueComparator?: (v1: Value, v2: Value) => boolean);

        set(key: Key, value: Value): void;
        get(key: Key): Value | undefined;
        has(key: Key): boolean;
        delete(key: Key): Value | undefined;
        clear(): void;
        forEach(fn: (value: Value, key: Key) => void, thisArg?: Object): void;

        entries(): IterableIterator<[Key, Value]>;
        keys(): IterableIterator<Key>;
        values(): IterableIterator<Value>;

        equals(other: HashMap<Key, Value>, valueComparator?: (v1: Value, v2: Value) => boolean): boolean;
        merge(from: HashMap<Key, Value>): void;

        readonly size: number;
    }

    export class Holder<T>
    {
        value: T;
    }

    export function stringToIdentity(s: string): Identity;

    export function identityToString(ident: Identity, toStringMode?: ToStringMode): string;

    export function proxyIdentityCompare(lhs: ObjectPrx, rhs: ObjectPrx): number;

    export function proxyIdentityAndFacetCompare(lhs: ObjectPrx, rhs: ObjectPrx): number;

    export class InitializationData {
        constructor();
        clone(): InitializationData;

        properties: Properties;
        logger: Logger;
        valueFactoryManager: ValueFactoryManager;
    }

    export function initialize(initData?: InitializationData): Communicator;

    export function initialize(args: string[], initData?: InitializationData): Communicator;

    export function createProperties(args?: string[], defaults?: Properties): Properties;

    export function currentProtocol(): ProtocolVersion;

    export function currentEncoding(): EncodingVersion;

    export function stringVersion(): string;

    export function intVersion(): number;

    export class Long {
        constructor(high?: number, low?: number);
        hashCode(): number;
        equals(rhs: Long): boolean;
        toString(): string;
        toNumber(): number;

        low: number;
        high: number;
    }

    export class MapUtil {
        static equals<K, V>(lhs: Map<K, V>, rhs: Map<K, V>): boolean;
    }

    export class Object {
        /**
         * Tests whether this object supports a specific Slice interface.
         * @param typeID The type ID of the Slice interface to test against.
         * @param current The Current object for the invocation.
         * @return True if this object has the interface specified by typeID
         * or derives from the interface specified by typeID.
         */
        ice_isA(typeID: string, current?: Current): boolean | PromiseLike<boolean>;

        /**
         * Tests whether this object can be reached.
         * @param current The Current object for the invocation.
         */
        ice_ping(current?: Current): void | PromiseLike<void>;

        /**
         * Returns the Slice type IDs of the interfaces supported by this object.
         * @param current The Current object for the invocation.
         * @return The Slice type IDs of the interfaces supported by this object, in base-to-derived
         * order. The first element of the returned array is always "::Ice::Object".
         */
        ice_ids(current?: Current): string[] | PromiseLike<string[]>;

        /**
         * Returns the Slice type ID of the most-derived interface supported by this object.
         * @param current The Current object for the invocation.
         * @return The Slice type ID of the most-derived interface.
         */
        ice_id(current?: Current): string | PromiseLike<string>;

        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::Object".
         */
        static ice_staticId(): string;
    }

    export class ObjectPrx {
        static ice_staticId(): string;

        /**
         * Tests whether this object supports a specific Slice interface.
         * @param typeId The type ID of the Slice interface to test against.
         * @param context The context map for the invocation.
         * @return The asynchronous result object for the invocation.
         */
        ice_isA(id: string, context?: Map<string, string>): AsyncResult<boolean>;

        /**
         * Returns the Slice type ID of the most-derived interface supported by the target object of this proxy.
         * @param context The context map for the invocation.
         * @return The asynchronous result object for the invocation.
         */
        ice_id(context?: Map<string, string>): AsyncResult<string>;

        /**
         * Returns the Slice type IDs of the interfaces supported by the target object of this proxy.
         * @param context The context map for the invocation.
         * @return The asynchronous result object for the invocation.
         */
        ice_ids(context?: Map<string, string>): AsyncResult<string[]>;

        /**
         * Tests whether the target object of this proxy can be reached.
         * @param context The context map for the invocation.
         * @return The asynchronous result object for the invocation.
         */
        ice_ping(context?: Map<string, string>): AsyncResult<void>;

        /**
         * Obtains the communicator that created this proxy.
         * @return The communicator that created this proxy.
         */
        ice_getCommunicator(): Communicator;

        /**
         * Obtains a stringified version of this proxy.
         * @return A stringified proxy.
         */
        ice_toString(): string;

        /**
         * Obtains a proxy that is identical to this proxy, except for the identity.
         * @param id The identity for the new proxy.
         * @return A proxy with the new identity.
         */
        ice_identity(id: Identity): this;

        /**
         * Obtains the identity embedded in this proxy.
         * @return The identity of the target object.
         */
        ice_getIdentity(): Identity;

        /**
         * Obtains a proxy that is identical to this proxy, except for the adapter ID.
         * @param id The adapter ID for the new proxy.
         * @return A proxy with the new adapter ID.
         */
        ice_adapterId(id: string): this;

        /**
         * Obtains the adapter ID for this proxy.
         * @return The adapter ID. If the proxy does not have an adapter ID, the return value is the empty string.
         */
        ice_getAdapterId(): string;

        /**
         * Obtains a proxy that is identical to this proxy, except for the endpoints.
         * @param endpoints The endpoints for the new proxy.
         * @return A proxy with the new endpoints.
         */
        ice_endpoints(endpoints: Endpoint[]): this;

        /**
         * Obtains the endpoints used by this proxy.
         * @return The endpoints used by this proxy.
         */
        ice_getEndpoints(): Endpoint[];

        /**
         * Obtains a proxy that is identical to this proxy, except for the endpoint selection policy.
         * @param type The new endpoint selection policy.
         * @return A proxy with the specified endpoint selection policy.
         */
        ice_endpointSelection(type: EndpointSelectionType): this;

        /**
         * Obtains the endpoint selection policy for this proxy (randomly or ordered).
         * @return The endpoint selection policy.
         */
        ice_getEndpointSelection(): EndpointSelectionType;

        /**
         * Obtains a proxy that is identical to this proxy, except for the per-proxy context.
         * @param context The context for the new proxy.
         * @return A proxy with the new per-proxy context.
         */
        ice_context(ctx: Map<string, string>): this;

        /**
         * Obtains the per-proxy context for this proxy.
         * @return The per-proxy context.
         */
        ice_getContext(): Map<string, string>;

        /**
         * Obtains a proxy that is identical to this proxy, except for the facet.
         * @param facet The facet for the new proxy.
         * @return A proxy with the new facet.
         */
        ice_facet(facet: string): this;

        /**
         * Obtains the facet for this proxy.
         * @return The facet for this proxy. If the proxy uses the default facet, the return value is the empty string.
         */
        ice_getFacet(): string;

        /**
         * Obtains a proxy that is identical to this proxy, but uses twoway invocations.
         * @return A proxy that uses twoway invocations.
         */
        ice_twoway(): this;

        /**
         * Determines whether this proxy uses twoway invocations.
         * @return True if this proxy uses twoway invocations, false otherwise.
         */
        ice_isTwoway(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, but uses oneway invocations.
         * @return A proxy that uses oneway invocations.
         */
        ice_oneway(): this;

        /**
         * Determines whether this proxy uses oneway invocations.
         * @return True if this proxy uses oneway invocations, false otherwise.
         */
        ice_isOneway(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, but uses batch oneway invocations.
         * @return A proxy that uses batch oneway invocations.
         */
        ice_batchOneway(): this;

        /**
         * Determines whether this proxy uses batch oneway invocations.
         * @return True if this proxy uses batch oneway invocations, false otherwise.
         */
        ice_isBatchOneway(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, but uses datagram invocations.
         * @return A proxy that uses datagram invocations.
         */
        ice_datagram(): this;

        /**
         * Determines whether this proxy uses datagram invocations.
         * @return True if this proxy uses datagram invocations, false otherwise.
         */
        ice_isDatagram(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, but uses batch datagram invocations.
         * @return A proxy that uses batch datagram invocations.
         */
        ice_batchDatagram(): this;

        /**
         * Determines whether this proxy uses batch datagram invocations.
         * @return True if this proxy uses batch datagram invocations, false otherwise.
         */
        ice_isBatchDatagram(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, except for how it selects endpoints.
         * @param secure If true, only endpoints that use a secure transport are used by the new proxy.
         * If false, the returned proxy uses both secure and insecure endpoints.
         * @return A proxy with the specified security policy.
         */
        ice_secure(secure: boolean): this;

        /**
         * Obtains the encoding version used to marshal request parameters.
         * @return The encoding version.
         */
        ice_getEncodingVersion(): EncodingVersion;

        /**
         * Obtains a proxy that is identical to this proxy, except for the encoding used to marshal
         * parameters.
         * @param version The encoding version to use to marshal request parameters.
         * @return A proxy with the specified encoding version.
         */
        ice_encodingVersion(encoding: EncodingVersion): this;

        /**
         * Determines whether this proxy uses only secure endpoints.
         * @return True if this proxy communicates only via secure endpoints, false otherwise.
         */
        ice_isSecure(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, except for its endpoint selection policy.
         * @param secure If true, the new proxy will use secure endpoints for invocations and only use
         * insecure endpoints if an invocation cannot be made via secure endpoints. If false, the
         * proxy prefers insecure endpoints to secure ones.
         * @return A proxy with the specified selection policy.
         */
        ice_preferSecure(secure: boolean): this;

        /**
         * Determines whether this proxy prefers secure endpoints.
         * @return True if the proxy always attempts to invoke via secure endpoints before it
         * attempts to use insecure endpoints, false otherwise.
         */
        ice_isPreferSecure(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, except for its compression setting which
         * overrides the compression setting from the proxy endpoints.
         * @param b True enables compression for the new proxy, false disables compression.
         * @return A proxy with the specified compression override setting.
         */
        ice_compress(compress: boolean): this;

        /**
         * Obtains the compression override setting of this proxy.
         * @return The compression override setting. If nullopt is returned, no override is set. Otherwise, true
         * if compression is enabled, false otherwise.
         */
        ice_getCompress(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, except for its connection timeout setting
         * which overrides the timeot setting from the proxy endpoints.
         * @param timeout The connection timeout override for the proxy (in milliseconds).
         * @return A proxy with the specified timeout override.
         */
        ice_timeout(timeout: number): this;

        /**
         * Obtains the timeout override of this proxy.
         * @return The timeout override. If nullopt is returned, no override is set. Otherwise, returns
         * the timeout override value.
         */
        ice_getTimeout(): number;

        /**
         * Obtains a proxy that is identical to this proxy, except for the router.
         * @param router The router for the new proxy.
         * @return A proxy with the specified router.
         */
        ice_router(router: RouterPrx): this;

        /**
         * Obtains the router for this proxy.
         * @return The router for the proxy. If no router is configured for the proxy, the return value
         * is nil.
         */
        ice_getRouter(): RouterPrx;

        /**
         * Obtains a proxy that is identical to this proxy, except for the locator.
         * @param locator The locator for the new proxy.
         * @return A proxy with the specified locator.
         */
        ice_locator(locator: LocatorPrx): this;

        /**
         * Obtains the locator for this proxy.
         * @return The locator for this proxy. If no locator is configured, the return value is nil.
         */
        ice_getLocator(): LocatorPrx;

        /**
         * Obtains a proxy that is identical to this proxy, except for the locator cache timeout.
         * @param timeout The new locator cache timeout (in seconds).
         * @return A proxy with the new timeout.
         */
        ice_locatorCacheTimeout(timeout: number): this;

        /**
         * Obtains the locator cache timeout of this proxy.
         * @return The locator cache timeout value (in seconds).
         */
        ice_getLocatorCacheTimeout(): number;

        /**
         * Obtains a proxy that is identical to this proxy, except for collocation optimization.
         * @param b True if the new proxy enables collocation optimization, false otherwise.
         * @return A proxy with the specified collocation optimization.
         */
        ice_collocationOptimized(b: boolean): this;

        /**
         * Determines whether this proxy uses collocation optimization.
         * @return True if the proxy uses collocation optimization, false otherwise.
         */
        ice_isCollocationOptimized(): boolean;

        /**
         * Obtains a proxy that is identical to this proxy, except for the invocation timeout.
         * @param timeout The new invocation timeout (in milliseconds).
         * @return A proxy with the new timeout.
         */
        ice_invocationTimeout(timeout: number): this;

        /**
         * Obtains the invocation timeout of this proxy.
         * @return The invocation timeout value (in milliseconds).
         */
        ice_getInvocationTimeout(): number;

        /**
         * Obtains a proxy that is identical to this proxy, except for its connection ID.
         * @param id The connection ID for the new proxy. An empty string removes the
         * connection ID.
         * @return A proxy with the specified connection ID.
         */
        ice_connectionId(connectionId: string): this;

        /**
         * Obtains the connection ID of this proxy.
         * @return The connection ID.
         */
        ice_getConnectionId(): string;

        /**
         * Obtains a proxy that is identical to this proxy, except it's a fixed proxy bound
         * the given connection.
         * @param connection The fixed proxy connection.
         * @return A fixed proxy bound to the given connection.
         */
        ice_fixed(conn: Connection): this;

        /**
         * Obtains the Connection for this proxy. If the proxy does not yet have an established connection,
         * it first attempts to create a connection.
         * @return The asynchronous result object for the invocation.
         */
        ice_getConnection(): AsyncResult<Connection>;

        /**
         * Obtains the cached Connection for this proxy. If the proxy does not yet have an established
         * connection, it does not attempt to create a connection.
         * @return The cached connection for this proxy, or nil if the proxy does not have
         * an established connection.
         */
        ice_getCachedConnection(): Connection;

        /**
         * Obtains a proxy that is identical to this proxy, except for connection caching.
         * @param cache True if the new proxy should cache connections, false otherwise.
         * @return A proxy with the specified caching policy.
         */
        ice_connectionCached(cache: boolean): this;

        /**
         * Determines whether this proxy caches connections.
         * @return True if this proxy caches connections, false otherwise.
         */
        ice_isConnectionCached(): boolean;

        /**
         * Flushes any pending batched requests for this communicator. The call blocks until the flush is complete.
         * @return The asynchronous result object for the invocation.
         */
        ice_flushBatchRequests(): AsyncResult<void>;

        /**
         * Invokes an operation dynamically.
         * @param operation The name of the operation to invoke.
         * @param mode The operation mode (normal or idempotent).
         * @param inParams An encapsulation containing the encoded in-parameters for the operation.
         * @return The asynchronous result object for the invocation .
         */
        ice_invoke(operation: string, mode: OperationMode, inEncaps: Uint8Array): AsyncResult<[]>;

        /**
         * Compare two proxies for equality
         * @param rhs The proxy to compare with this proxy
         * @returns True if the passed proxy have the same reference than this proxy.
         */
        equals(rhs: any): boolean;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx: ObjectPrx, facet?: string): ObjectPrx;

        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx: ObjectPrx, facet?: string, contex?: Map<string, string>): AsyncResult<ObjectPrx>;
    }

    export class OptionalFormat {
        static readonly F1: OptionalFormat;
        static readonly F2: OptionalFormat;
        static readonly F4: OptionalFormat;
        static readonly F8: OptionalFormat;
        static readonly Size: OptionalFormat;
        static readonly VSize: OptionalFormat;
        static readonly FSize: OptionalFormat;
        static readonly Class: OptionalFormat;

        static valueOf(value: number): OptionalFormat;
        equals(other: any): boolean;
        hashCode(): number;
        toString(): string;

        readonly name: string;
        readonly value: number;
    }

    export { P as Promise };

    export const Encoding_1_0: EncodingVersion;

    export const Encoding_1_1: EncodingVersion;

    export const Protocol_1_0: ProtocolVersion;

    export class Protocol {
        //
        // Size of the Ice protocol header
        //
        // Magic number (4 bytes)
        // Protocol version major (Byte)
        // Protocol version minor (Byte)
        // Encoding version major (Byte)
        // Encoding version minor (Byte)
        // Message type (Byte)
        // Compression status (Byte)
        // Message size (Int)
        //
        static readonly headerSize: number;

        //
        // The magic number at the front of each message ['I', 'c', 'e', 'P']
        //
        static readonly magic: Uint8Array;

        //
        // The current Ice protocol and encoding version
        //
        static readonly protocolMajor: number;
        static readonly protocolMinor: number;
        static readonly protocolEncodingMajor: number;
        static readonly protocolEncodingMinor: number;

        static readonly encodingMajor: number;
        static readonly encodingMinor: number;

        //
        // The Ice protocol message types
        //
        static readonly requestMsg: number;
        static readonly requestBatchMsg: number;
        static readonly replyMsg: number;
        static readonly validateConnectionMsg: number;
        static readonly closeConnectionMsg: number;

        //
        // Reply status
        //
        static readonly replyOK: number;
        static readonly replyUserException: number;
        static readonly replyObjectNotExist: number;
        static readonly replyFacetNotExist: number;
        static readonly replyOperationNotExist: number;
        static readonly replyUnknownLocalException: number;
        static readonly replyUnknownUserException: number;
        static readonly replyUnknownException: number;

        static readonly requestHdr: Uint8Array;

        static readonly requestBatchHdr: Uint8Array;

        static readonly replyHdr: Uint8Array;

        static readonly currentProtocol: ProtocolVersion;
        static readonly currentProtocolEncoding: EncodingVersion;

        static currentEncoding: EncodingVersion;

        static checkSupportedProtocol(v: ProtocolVersion): void;
        static checkSupportedProtocolEncoding(v: EncodingVersion): void;
        static checkSupportedEncoding(version: EncodingVersion): void;

        //
        // Either return the given protocol if not compatible, or the greatest
        // supported protocol otherwise.
        //
        static getCompatibleProtocol(version: ProtocolVersion): ProtocolVersion;

        //
        // Either return the given encoding if not compatible, or the greatest
        // supported encoding otherwise.
        //
        static getCompatibleEncoding(version: EncodingVersion): EncodingVersion;

        static isSupported(version: ProtocolVersion, supported: ProtocolVersion): boolean;
        static isSupported(version: EncodingVersion, supported: EncodingVersion): boolean;

        static readonly OPTIONAL_END_MARKER: number;
        static readonly FLAG_HAS_TYPE_ID_STRING: number;
        static readonly FLAG_HAS_TYPE_ID_INDEX: number;
        static readonly FLAG_HAS_TYPE_ID_COMPACT: number;
        static readonly FLAG_HAS_OPTIONAL_MEMBERS: number;
        static readonly FLAG_HAS_INDIRECTION_TABLE: number;
        static readonly FLAG_HAS_SLICE_SIZE: number;
        static readonly FLAG_IS_LAST_SLICE: number;
    }

    /**
     * Converts a string to a protocol version.
     */
    export function stringToProtocolVersion(version: string): ProtocolVersion;

    /**
     * Converts a string to an encoding version.
     */
    export function stringToEncodingVersion(version: string): EncodingVersion;

    /**
     * Converts a protocol version to a string.
     */
    export function protocolVersionToString(version: ProtocolVersion): string;

    /**
     * Converts an encoding version to a string.
     */
    export function encodingVersionToString(version: EncodingVersion): string;

    export class ByteHelper {
        static validate(v: number): boolean;
    }

    export class ShortHelper {
        static validate(v: number): boolean;
    }

    export class IntHelper {
        static validate(v: number): boolean;
    }

    export class FloatHelper {
        static validate(v: number): boolean;
    }

    export class DoubleHelper {
        static validate(v: number): boolean;
    }

    export class LongHelper {
        static validate(v: Long): boolean;
    }

    export class InputStream {
        constructor();
        constructor(buffer: Uint8Array);
        constructor(communicator: Communicator);
        constructor(communicator: Communicator, buffer: Uint8Array);
        constructor(encoding: EncodingVersion);
        constructor(encoding: EncodingVersion, buffer: Uint8Array);
        constructor(communicator: Communicator, encoding: EncodingVersion);
        constructor(communicator: Communicator, encoding: EncodingVersion, buffer: Uint8Array);

        //
        // This function allows this object to be reused, rather than reallocated.
        //
        reset(): void;
        clear(): void;
        swap(other: InputStream): void;
        resetEncapsulation(): void;
        resize(sz: number): void;
        startValue(): void;
        endValue(preserve: boolean): SlicedData;
        startException(): void;
        endException(preserve: boolean): SlicedData;
        startEncapsulation(): EncodingVersion;
        endEncapsulation(): void;
        skipEmptyEncapsulation(): EncodingVersion;
        readEncapsulation(encoding: EncodingVersion): Uint8Array;
        getEncoding(): EncodingVersion;
        getEncapsulationSize(): number;
        skipEncapsulation(): EncodingVersion;
        startSlice(): string; // Returns type ID of next slice
        endSlice(): void;
        skipSlice(): void;
        readPendingValues(): void;
        readSize(): number;
        readAndCheckSeqSize(minSize: number): number;
        readBlob(sz: number): Uint8Array;
        readOptional(tag: number, expectedFormat: OptionalFormat): boolean;
        readByte(): number;
        readByteSeq(): Uint8Array;
        readBool(): boolean;
        readShort(): number;
        readInt(): number;
        readLong(): Ice.Long;
        readFloat(): number;
        readDouble(): number;
        readString(): string;

        readProxy<T extends ObjectPrx>(type: new () => T): T;
        readOptionalProxy<T extends ObjectPrx>(tag: number, type: new () => T): T | undefined;
        readEnum<T>(type: new () => T): T;
        readOptionalEnum<T>(tag: number, type: new () => T): T | undefined;
        readValue<T extends Value>(cb: (value: T) => void, type: new () => T): void;
        readOptionalValue<T extends Value>(tag: number, cb: (value: T) => void, type: new () => T): void;
        throwException(): void;
        skip(size: number): void;
        skipSize(): void;
        isEmpty(): boolean;
        expand(n: number): void;

        //
        // Sets the value factory manager to use when marshaling value instances. If the stream
        // was initialized with a communicator, the communicator's value factory manager will
        // be used by default.
        //
        valueFactoryManager: ValueFactoryManager;

        //
        // Sets the logger to use when logging trace messages. If the stream
        // was initialized with a communicator, the communicator's logger will
        // be used by default.
        //
        logger: Logger;

        //
        // Sets the compact ID resolver to use when unmarshaling value and exception
        // instances. If the stream was initialized with a communicator, the communicator's
        // resolver will be used by default.
        //
        compactIdResolver: (compactID: number) => string;

        //
        // Determines the behavior of the stream when extracting instances of Slice classes.
        // A instance is "sliced" when a factory cannot be found for a Slice type ID.
        // The stream's default behavior is to slice instances.
        //
        // If slicing is disabled and the stream encounters a Slice type ID
        // during decoding for which no value factory is installed, it raises
        // NoValueFactoryException.
        //
        sliceValues: boolean;

        //
        // Determines whether the stream logs messages about slicing instances of Slice values.
        //
        traceSlicing: boolean;

        pos: number;

        readonly size: number;
        readonly buffer: Uint8Array;
    }

    export class OutputStream {
        constructor(communicator?: Ice.Communicator, encoding?: EncodingVersion, buffer?: Uint8Array);

        //
        // This function allows this object to be reused, rather than reallocated.
        //
        reset(): void;
        clear(): void;
        finished(): Uint8Array;
        swap(other: OutputStream): void;
        resetEncapsulation(): void;
        resize(sz: number): void;
        prepareWrite(): Uint8Array;
        startValue(data: SlicedData): void;
        endValue(): void;
        startException(data: SlicedData): void;
        endException(): void;
        startEncapsulation(): void;
        startEncapsulation(encoding: EncodingVersion, format: FormatType): void;
        endEncapsulation(): void;
        writeEmptyEncapsulation(encoding: EncodingVersion): void;
        writeEncapsulation(buff: Uint8Array): void;
        getEncoding(): EncodingVersion;
        startSlice(typeId: string, compactId: number, last: boolean): void;
        endSlice(): void;
        writePendingValues(): void;
        writeSize(v: number): void;
        startSize(): number;
        endSize(pos: number): void;
        writeBlob(v: Uint8Array): void;
        // Read/write format and tag for optionals
        writeOptional(tag: number, format: OptionalFormat): void;
        writeByte(v: number): void;
        writeByteSeq(v: Uint8Array): void;
        writeBool(v: boolean): void;
        writeShort(v: number): void;
        writeInt(v: number): void;
        writeLong(v: Ice.Long): void;
        writeFloat(v: number): void;
        writeDouble(v: number): void;
        writeString(v: string): void;
        writeProxy(v: ObjectPrx): void;
        writeOptionalProxy(tag: number, v?: ObjectPrx | undefined): void;

        /// TODO use a base enum type
        writeEnum(v: any): void;

        writeValue(v: Ice.Value): void;
        writeOptionalValue(tag: number, v?: Ice.Value | undefined): void;
        writeException(e: UserException): void;
        writeUserException(e: UserException): void;

        isEmpty(): boolean;

        expand(n: number): void;

        //
        // Sets the encoding format for class and exception instances.
        //
        format: FormatType;
        pos: number;
        readonly size: number;
        readonly buffer: Uint8Array;
    }

    /**
     * Generates a universally unique identifier (UUID).
     */
    export function generateUUID(): string;

    /**
     * Encapsulates the details of a slice for an unknown class or exception type.
     */
    export class SliceInfo {
        /**
         * The Slice type ID for this slice.
         */
        typeId: string;

        /**
         * The Slice compact type ID for this slice.
         */
        compactId: number;

        /**
         * The encoded bytes for this slice, including the leading size integer.
         */
        bytes: Uint8Array;

        /**
         * The class instances referenced by this slice.
         */
        instances: Value[];

        /**
         * Whether or not the slice contains optional members.
         */
        hasOptionalMembers: boolean;

        /**
         * Whether or not this is the last slice.
         */
        isLastSlice: boolean;
    }

    /**
     * Holds the slices of unknown types.
     */
    export class SlicedData {
        /**
         * The slices of unknown types.
         */
        slices: SliceInfo[];
    }

    export class UnknownSlicedValue extends Ice.Value {
        constructor(unknownTypeId: string);

        ice_getSlicedData(): SlicedData;
        ice_id(): string;
    }

    /**
     * The base class for instances of Slice classes.
     */
    export class Value {
        /**
         * The Ice run time invokes this method prior to marshaling an object's data members. This allows a subclass
         * to override this method in order to validate its data members.
         */
        ice_preMarshal(): void;

        /**
         * The Ice run time invokes this method vafter unmarshaling an object's data members. This allows a
         * subclass to override this method in order to perform additional initialization.
         */
        ice_postUnmarshal(): void;

        /**
         * Obtains the Slice type ID of the most-derived class supported by this object.
         * @return The type ID.
         */
        ice_id(): string;

        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Ice::Object".
         */
        static ice_staticId(): string;

        /**
         * Obtains the sliced data associated with this instance.
         * @return The sliced data if the value has a preserved-slice base class and has been sliced during
         * unmarshaling of the value, nil otherwise.
         */
        ice_getSlicedData(): SlicedData;
    }

    export class InterfaceByValue extends Value {
        constructor(id: string);
    }

}