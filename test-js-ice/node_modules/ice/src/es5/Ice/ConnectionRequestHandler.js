"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ReferenceMode").Ice;

var ReferenceMode = Ice.ReferenceMode;

var ConnectionRequestHandler =
/*#__PURE__*/
function () {
  function ConnectionRequestHandler(ref, connection) {
    _classCallCheck(this, ConnectionRequestHandler);

    this._reference = ref;
    this._response = ref.getMode() == ReferenceMode.ModeTwoway;
    this._connection = connection;
  }

  _createClass(ConnectionRequestHandler, [{
    key: "update",
    value: function update(previousHandler, newHandler) {
      try {
        if (previousHandler === this) {
          return newHandler;
        } else if (previousHandler.getConnection() === this._connection) {
          //
          // If both request handlers point to the same connection, we also
          // update the request handler. See bug ICE-5489 for reasons why
          // this can be useful.
          //
          return newHandler;
        }
      } catch (ex) {// Ignore
      }

      return this;
    }
  }, {
    key: "sendAsyncRequest",
    value: function sendAsyncRequest(out) {
      return out.invokeRemote(this._connection, this._response);
    }
  }, {
    key: "asyncRequestCanceled",
    value: function asyncRequestCanceled(out) {
      return this._connection.asyncRequestCanceled(out);
    }
  }, {
    key: "getReference",
    value: function getReference() {
      return this._reference;
    }
  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._connection;
    }
  }]);

  return ConnectionRequestHandler;
}();

Ice.ConnectionRequestHandler = ConnectionRequestHandler;
module.exports.Ice = Ice;